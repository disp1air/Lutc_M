В Python 3.0 пользовательские исключения наследуют суперклассы встроенных исключений.  

В обеих версиях Python, 2.6 и 3.0, исключения должны определяться как классы. Кроме того, в версии 3.0 требуется, чтобы классы исключений наследовали суперкласс встроенного исключения BaseException, прямо или косвенно. В большинстве случаев пользовательские исключения наследуют подкласс Exception этого класса для поддержки универсальных обработчиков исключений обычных типов – при указании имени этого класса в обработчике большинство программ будут перехватывать все исключения, которые они должны перехватывать.  

То есть, когда в инструкции try предложение except содержит суперкласс, оно будет перехватывать экземпляры этого суперкласса, а также экземпляры всех его подклассов, расположенных ниже в дереве наследования.  

                                    class General(Exception): pass
                                    class Specific1(General): pass
                                    class Specific2(General): pass

                                    def raiser0():
                                        X = General()
                                        raise X  

                                    def raiser1():
                                        X = Specific1()
                                        raise X

                                    def raiser2():
                                        X = Specific2()
                                        raise X

                                    for func in (raiser0, raiser1, raiser2):
                                        try:
                                            func()
                                        except General:
                                            import sys
                                            print('caught:', sys.exc_info()[0])

                                    caught: <class '__main__.General'>
                                    caught: <class '__main__.Specific1'>
                                    caught: <class '__main__.Specific2'>

Если в инструкции raise имена классов указываются без круглых скобок, интерпретатор будет автоматически создавать экземпляры, вызывая их конструкторы без аргументов.  

sys.exc_info – эта функция обеспечивает обобщенный способ получить последнее возбужденное исключение. В двух словах, первый элемент в полученном результате – это класс возбужденного исключения, а второй – фактический экземпляр исключения.  

тип исключения можно также получить из атрибута \_\_class__ экземпляра.  

                                    class General(Exception): pass
                                    class Specific1(General): pass
                                    class Specific2(General): pass

                                    def raiser0(): raise General()
                                    def raiser1(): raise Specific1()
                                    def raiser2(): raise Specific2()

                                    for func in (raiser0, raiser1, raiser2):
                                        try:
                                            func()
                                        except General as X: # X – возбужденный экземпляр
                                            print('caught:', X.__class__) # То же, что и sys.exc_info()[0]

в случае разветвленных или глубоких иерархий исключений, может оказаться гораздо проще перехватывать категории,
используя классы, чем перечислять в предложении except все исключения, входящие в категорию.  

**Классы встроенных исключений**  
Все встроенные исключения, которые могут возбуждаться интерпретатором, являются объектами предопределенных классов. Кроме того, они организованы в неглубокую иерархию с общими суперклассами категорий и подклассами определенных типов исключений.  

В Python 3.0 все исключения в действительности являются обычными классами, доступными в виде встроенных имен в модуле builtins и в виде атрибутов модуля exceptions, входящего в состав стандартной библиотеки. Кроме того, в языке Python встроенные исключения организованы в иерархию с целью поддержки различных режимов перехвата исключений. Например:  

**BaseException** - корневой суперкласс исключений. Этот класс не предназначен для непосредственного наследования пользовательскими классами (для этого следует использовать класс Exception). Он содержит реализацию по умолчанию вывода сообщений и обеспечивает сохранение информации о состоянии. Если встроенной функции str передать экземпляр этого класса (например, с помощью функции print), класс вернет строку с аргументами, которые передавались конструктору при создании экземпляра (или пустую строку, если конструктор вызывался без аргументов). Кроме того, если подклассы не переопределяют конструктор этого класса, все аргументы, передаваемые ему при создании экземпляра, сохраняются в атрибуте args экземпляра
в виде кортежа.  

**Exception** - корневой суперкласс всех прикладных исключений. Это прямой потомок суперкласса BaseException и суперкласс для всех других встроенных исключений, кроме классов, связанных с событиями завершения программы (SystemExit,
KeyboardInterrupt и GeneratorExit). Почти все пользовательские классы исключений должны наследовать этот класс, а не BaseException. При соблюдении этого соглашения предложения except инструкции try, в которых указано исключение Exception, будут перехватывать все исключения, кроме событий завершения программы, которые обычно обрабатывать не требуется. В результате использование имени Exception в инструкции try обеспечивает более точную избирательность, чем пустое предложение except.  

**ArithmeticError** - суперкласс всех арифметических ошибок (и подкласс класса Exception).  

**OverflowError** - подкласс класса ArithmeticError, идентифицирующий конкретную арифметическую ошибку.  

Дерево встроенных классов позволяет определять, насколько конкретными или универсальными будут ваши обработчики исключений. Например, встроенное исключение ArithmeticError – это суперкласс для таких более конкретных исключений, как OverflowError и ZeroDivisionError. Указав имя ArithmeticError в инструкции try, вы будете перехватывать все арифметические ошибки, а указав имя OverflowError, вы будете перехватывать только ошибки определенного типа и никакие другие.  

Точно так же можно использовать исключение Exception – суперкласс всех прикладных исключений в Python 3.0, чтобы организовать обработку всех исключений. Использование этого класса по своему действию напоминает пустое предложение except, но позволяет игнорировать исключения, связанные с завершением программы.  

Если, наследуя встроенные классы исключений, вы не переопределяете конструктор суперкласса, любые аргументы, передаваемые конструктору, будут сохраняться в атрибуте args экземпляра и автоматически включаться в текст сообщения при выводе экземпляра (если конструктор вызывался без аргументов, будут выведены пустой кортеж и стандартная строка сообщения).

                                    >>> raise IndexError # То же, что и IndexError(): нет аргументов
                                    Traceback (most recent call last):
                                        File “<stdin>”, line 1, in <module>
                                    IndexError

                                    >>> raise IndexError(‘spam’) # Конструктор присоединит аргумент
                                    Traceback (most recent call last):
                                        File “<stdin>”, line 1, in <module>
                                    IndexError: spam

                                    >>> I = IndexError(‘spam’) # Аргументы доступны в виде атрибута
                                    >>> I.args
                                    (‘spam’,)

Помимо поддержки гибких иерархий классы исключений также являются удобным местом для хранения дополнительной информации в виде атрибутов экземпляров. Как мы уже видели выше, суперклассы встроенных исключений реализуют конструктор по умолчанию, который автоматически сохраняет аргументы в экземпляре, в виде кортежа, в атрибуте с именем args.  

При возбуждении исключения вместе с ним интерпретатор передает экземпляр класса. Обработчики в инструкциях try могут получить доступ к экземплярам возбужденных исключений, если в предложении except указать имя переменной после ключевого слова as. Этот прием обеспечивает естественный способ передачи данных и поведения обработчику.  
