Допустим есть простейшая функция min  

              def min(x, y):
                  return x if x < y else y

              min(3, 5)  
              min(x=3, y=5) - можем явно указывать имена аргументов  
              min(y=5, x=3) - можно переставлять аргументы т.к. указаны имена  

1. Перепишем функцию min для произвольного количества аргументов  
    Упаковка аргументов: все аргументы которые передадим - упакуются в кортеж args 

              def min(*args): # type(args) == tuple
                  res = float("inf") # максимальное значение infinity  
                  for arg in args:
                      if arg < res:
                          res = arg
                  return res

              min(-5, 12, 13) # -5
              min() # inf

Как потребовать, чтобы в args был хотя бы один элемент - потребовать один бязательный аргумент а потом уже любое кол-во.  

              def min(first, *args):
                  ...

              в таком случае при вызове функции min без аргументов - возникнет ошибка:
              TypeError: min() missing 1 requires argument 'first'


2. Перепишем функцию min чтобы она могла принимать кортежи, списки и другие последовательности.    

  Распаковка аргументов - синтаксис будет работать с любым объектом, поддерживающим протокол итератора.  

  xs = {-5, 12, 13}
  min(*xs) # -5

  min(*[-5, 12, 13]) # -5

  min(*(-5, 12, 13)) # -5 Но в этом случае не известен порядок подстановки аргументов. Т.к. это хэш-сет то у него нет порядка, более того порядок рандомизируется при старте.  


Аргументы по умолчанию

в какой момент происходит инициализация ключевых аргументов со значениями по умолчанию?   
Значения аргументов по умолчанию инициализируются один раз, в момент компиляции в байт-код  

    def unique(iterable, seen=set()):
        acc = []
        for item in iterable:
            if item not in seen:
                seen.add(item)
                acc.append(item)
        return acc

    xs = [1, 1, 2, 3]
    unique(xs) # [1, 2, 3]
    unique(xs) # {}

    unique.__defaults__ # ({1, 2, 3}, )  

Общее правило - никогда не использовать изменяемые значения в качестве значений по умолчанию!!!  

У каждой функции есть атрибут __defaults__(кортеж с инициализируемыми значениями аргументов по умолчанию)  

Только ключевые элементы требуют чтобы при вызове функции имя всегда было. Можно явно потребовать чтобы часть аргументов всегда передавалась как ключевые:  

    def foo(xs, *, depth=None):
        pass


Ключевые элементы аналогично позиционным можно упаковывать и распаковывать:  

    def runner(cmd, **kwargs):

Т.е. все что мы передаем в качестве ключевых аргументов соберется в kwargs 

3. Ограничим минимум произвольным отрезком  


