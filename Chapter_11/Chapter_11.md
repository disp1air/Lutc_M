 - Инструкция присваивания создает ссылку на объект.
 - Переменные создаются при первом присваивании.
 - Нельзя использовать переменную, которой еще не было присвоено значение.
 - Некоторые инструкции неявно тоже выполняют операцию присваивания.Например импорт модуля, определение функции или     класса, указание переменной в цикле for и передача аргументов функции неявно выполняют присваивание.

!!! Для определения кортежа мы можем просто перечислить значения через запятую без применения скобок:

                                        >>> a = 1
                                        >>> b = 2
                                        >>> a, b
                                        (1, 2)

 - Присваивание кортежей и списков
Когда слева от оператора = указывается кортеж или список, интерпретатор связывает объекты справа с именами слева, согласно их местоположениям, выполняя присваивание слева направо. с именем spam ассоциируется строка ‘yum’, а с именем ham ассоциируется строка ‘YUM’. Внутри интерпретатор Python сначала создает элементы кортежа справа, поэтому часто эта операция называется распаковыванием кортежа.  

                                        spam, ham = 'yum', 'YUM'

 - присваивание последовательностей
В недавних версиях Python операции присваивания кортежей и списков были обобщены в то, что теперь называется операцией присваивания последовательностей, – любая последовательность имен может быть связана с любой последовательностью значений, и интерпретатор свяжет элементы согласно их позициям. Фактически в последовательностях мы можем смешивать разные типы:  

                                        a, b, c, d = 'spam'

 - Расширенное распаковывание последовательностей
  
                                        a, *b = 'spam'

 - Групповое присваивание одного значения

 - Комбинированное присваивание

**присваивание последовательностей**
                                        >>> nudge = 1
                                        >>> wink = 2
                                        >>> A, B = nudge, wink # Присваивание кортежей
                                        >>> A, B # Что равносильно A = nudge; B = wink
                                        (1, 2)

В данной инструкции(>>> A, B = nudge, wink) в действительности присутствуют два кортежа, просто мы опустили охватывающие их круглые скобки. Интерпретатор Python сопоставляет значения элементов кортежа справа от оператора присваивания с переменными в кортеже слева и выполняет присваивание значений в одной инструкции.

Аналогичная ситуация со списками:
                                        >>> [C, D] = [nudge, wink] # Присваивание списков
                                        >>> C, D
                                        (1, 2)

Допускается присваивать кортеж значений списку переменных:

                                        >>> [a, b, c] = (1, 2, 3) # Кортеж значений присваивается списку переменных
                                        >>> a, c
                                        (1, 3)

Также можно присваивать строки символов – кортежу переменных и так далее. В любом случае интерпретатор свяжет элементы последовательности справа с переменными в последовательности слева согласно их позициям в направлении слева направо:

                                        >>> (a, b, c) = 'ABC' # Строка символов присваивается кортежу переменных
                                        >>> a, c
                                        ('A', 'C')

С технической точки зрения в правой части инструкции присваивания последовательностей допускается указывать не только последовательности, но и любые объекты, обеспечивающие возможность итераций по элементам.

Даже при том, что допускается смешивать разные типы последовательностей по обе стороны оператора =, обе последовательности должны иметь одно и то же число элементов, в противном случае мы получим сообщение об ошибке.

мы можем присваивать даже вложенные последовательности, и интерпретатор распаковывает их части в соответствии с их представлением, как и ожидается:  

                                        >>> ((a, b), c) = (‘SP’, ‘AM’)
                                        >>> a, b, c
                                        (‘S’, ‘P’, ‘AM’)

Интерпретатор связывает первую строку справа (‘SP’) с первым кортежем слева ((a, b)), присваивая каждому его элементу по одному символу, а затем выполняет присваивание второй строки целиком (‘AM’) переменной c. В этом случае вложенная последовательность слева, имеющая форму объекта, должна соответствовать объекту справа.

присваиванию последовательности целых чисел множеству переменных:

                                        >>> red, green, blue = range(3)
                                        >>> red, blue
                                        (0, 2)

range генерирует непрерывный список последовательных целых чисел:

                                        >>> range(3)
                                        [0, 1, 2]

**Расширенная операция распаковывания последовательностей**  
В двух словах: чтобы описать более общий случай присваивания, слева от оператора присваивания допускается указывать одно имя со звездочкой, например *X, – имени со звездочкой будет присвоен список всех элементов последовательности, не присвоенных другим переменным слева.

                                        >>> seq = [1, 2, 3, 4]
                                        >>> a, *b = seq
                                        >>> a
                                        1
                                        >>>b
                                        [1, 2, 3]

Имя со звездочкой может указываться в любой позиции слева:
                                        >>> *a, b = [1, 2, 3, 4]
                                        >>> a
                                        [1, 2, 3]
                                        >>> b
                                        4

                                        >>> a, *b, c = [1, 2, 3, 4]
                                        >>> a
                                        1
                                        >>> b
                                        [2, 3]
                                        >>> c
                                        4

Как и обычная операция присваивания последовательностей, расширенная операция распаковывания последовательностей может применяться к последовательностям любых типов, не только к спискам:  

                                        >>> a, *b = 'spam'
                                        >>> a, b
                                        ('s', ['p', 'a', 'm'])

                                        >>> a, *b, c = 'spam'
                                        >>> a, b, c
                                        ('s', ['p', 'a'], 'm')

Этот прием напоминает способ, основанный на извлечении срезов, но это не совсем одно и то же – инструкция присваивания последовательностей всегда возвращает список с множеством соответствующих элементов, тогда как операция извлечения среза возвращает последовательность того же типа, что и последовательность, из которой извлекается срез.  

                                        >>> L = [1, 2, 3, 4]
                                        >>> while L:
                                                front, *L = L # Получить первый и остальные элементы
                                                print(front, L) # без операции извлечения среза

                                        1 [2, 3, 4]
                                        2 [3, 4]
                                        3 [4]
                                        4 []

Граничные случаи:
 - переменной со звездочкой может соответствовать единственный элемент, но ей всегда присваивается список:

                                        >>> a, b, c, *d = [1, 2, 3, 4]
                                        >>> print(a, b, c, d)
                                        1 2 3 [4]

 - если на долю переменной со звездочкой не остается неприсвоенных элементов, ей присваивается пустой список,         независимо от того, в какой позиции эта переменная находится:

                                        >>> a, b, c, d, *e = [1, 2, 3, 4]
                                        >>> print(a, b, c, d, e)
                                        1 2 3 4 []

                                        >>> a, b, *e, c, d = seq
                                        >>> print(a, b, c, d, e)
                                        1 2 3 4 []

 - Наконец, ошибкой будет считаться, если указать несколько переменных со звездочкой и если переменная со звездочкой окажется единственной вне последовательности:

                                        >>> a, *b, c, *d = seq
                                        SyntaxError: two starred expressions in assignment
                                        
                                        >>> *a = seq
                                        SyntaxError: starred assignment target must be in a list or tuple

                                        >>> *a, = seq
                                        >>> a
                                        [1, 2, 3, 4]  

**Использование в циклах for**
Поскольку переменные цикла в инструкции for также участвуют в присваивании, расширенная операция распаковывания последовательностей может применяться и к ним.  

                                        for (a, *b, c) in [(1, 2, 3, 4), (5, 6, 7, 8)]:

При таком использовании в каждой итерации интерпретатор будет просто присваивать очередной кортеж значений кортежу переменных. На первом проходе, например, будет выполнено присваивание, как если бы оно было реализовано в виде выражения:

                                        a, *b, c = (1, 2, 3, 4) # Переменная b получит значение [2, 3]

**Групповое присваивание**  
При групповом присваивании объект, расположенный справа, присваивается всем указанным переменным. В следующем примере трем переменным a, b и c присваивается строка ‘spam’:  

                                        >>> a = b = c = ‘spam’
                                        >>> a, b, c
                                        (‘spam’, ‘spam’, ‘spam’)

Эта инструкция эквивалентна (но записывается компактнее) следующим трем инструкциям присваивания:  

                                        >>> c = ‘spam’
                                        >>> b = c
                                        >>> a = b

При этом виде присваивания нужно быть осторожным с изменяемыми объектами.  

                                        >>> a = b = []
                                        >>> b.append(42)
                                        >>> a, b
                                        ([42], [42])

**Комбинированные инструкции присваивания**  
Комбинированные операции присваивания существуют для любого поддерживаемого двухместного оператора.  

Для объектов, поддерживающих возможность непосредственного изменения, комбинированные инструкции присваивания автоматически выполняются непосредственно на самих объектах, вместо выполнения более медленной операции копирования.

!!!??? в результате операции конкатенации всегда создается новый объект
При использовании комбинированной инструкции присваивания(+=) для расширения списка, интерпретатор автоматически вызовет более быстрый метод extend вместо использования более медленной операции конкатенации, которую предполагает оператор +.  

применительно к спискам операция += выполняет изменения непосредственно в объекте, а это далеко не то же самое, что
операция конкатенации +, в результате которой всегда создается новый объект.
                                        
                                        >>> L = [1, 2]
                                        >>> M = L      # L и M ссылаются на один и тот же объект
                                        >>> L = L + [3, 4]      # Операция конкатенации создает новый объект
                                        >>> L, M # Изменяется L, но не M
                                        ([1, 2, 3, 4], [1, 2])

                                        >>> L = [1, 2]
                                        >>> M = L
                                        >>> L += [3, 4]     # Операция += предполагает вызов метода extend
                                        >>> L, M     # Значение M тоже изменилось!
                                        ([1, 2, 3, 4], [1, 2, 3, 4])

Все это имеет значение только для изменяемых объектов, таких как списки и словари.

**правила именования переменных**  
поскольку имена модулей в инструкции import становятся переменными в ваших сценариях, это накладывает ограничения на имена файлов с модулями. Вы можете создать файлы с именами and.py и my-code.py, но вы не сможете импортировать их, потому что их имена без расширения «.py» в программном коде будут преобразованы в имена переменных и поэтому должны следовать правилам (зарезервированные слова запрещены, а символы дефиса являются недопустимыми, хотя можно использовать символы подчеркивания).

Имена, начинающиеся с одного символа подчеркивания (_X), не импортируются инструкцией from module import *

**Инструкции выражений???**
функция print возвращает значение, как и любая другая функция (она возвращает значение None – оно возвращается всеми
функциями, которые явно не возвращают какого-либо значимого значения):

                                        >>> x = print('spam')
                                        spam                 
                                        >>> x                
                                        >>> print(x)         
                                        None                 

Print
Поток стандартного вывода в языке Python (известный под именем stdout) – это просто объект, куда программы выводят текст. Наряду с потоками стандартного ввода и стандартного вывода сообщений об ошибках, поток стандартного вывода является одним из трех потоков, которые создаются в момент запуска сценария. Поток стандартного вывода обычно отображается на окно терминала, где была запущена программа на языке Python, если явно не было выполнено перенаправление вывода в файл или в конвейер системной командной оболочки.

Так как поток стандартного вывода в языке Python доступен в виде объекта stdout из встроенного модуля sys (то есть sys.stdout), вполне возможно имитировать поведение инструкции print с помощью методов записи в файл, хотя использование print выглядит проще.