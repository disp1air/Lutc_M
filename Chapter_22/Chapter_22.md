Вы можете называть ваши модули, как вам будет угодно, при условии, что эти имена будут оканчиваться расширением .py, если вы собираетесь импортировать их. Для главных файлов программ, которые будут запускаться, но не будут импортироваться, имена не обязательно должны иметь расширение .py, однако было бы желательно использовать это расширение в любом случае, потому что оно делает назначение файлов более очевидным и позволит в будущем импортировать любой из ваших файлов.

Имена модулей внутри программы превращаются в имена переменных, следовательно они также должны следовать правилам именования
обычных переменных. Например, можно создать файл модуля с именем if.py, но его невозможно будет импортировать, потому что if – это зарезервированное слово, и когда вы попытаетесь выполнить инструкцию import if, интерпретатор выдаст сообщение о синтаксической ошибке.  

Когда производится импорт модуля, интерпретатор Python преобразует имя модуля в имя внешнего файла, добавляя в начало путь к каталогу из пути поиска модулей и добавляя .py или другое расширение в конец.

Обе инструкции(import и from) отыскивают, компилируют и запускают программный код модуля, если он еще не был за-
гружен. Главное различие этих инструкций заключается в том, что инструкция import загружает модуль целиком, поэтому при обращении к именам в модуле их необходимо дополнять именем модуля. Инструкция from, напротив, загружает (или копирует) из модуля отдельные имена.

Модули загружаются и запускаются первой, и только первой инструкцией import или from. Реализовано такое поведение преднамеренно, потому что импортирование – это дорогостоящая операция и интерпретатор выполняет ее всего один раз за все время работы. Последующие операции импорта просто получают объект уже загруженного модуля. Вторая и все последующие операции импортирования не приводят к перезапуску программного кода модуля – они просто получают объект модуля из внутренней таблицы модулей интерпретатора.

!!!??? - отличие инструкций от объявлений времени компиляции

Так же, как и инструкция def, инструкции import и from являются выполняемыми инструкциями, а не объявлениями времени компиляции. Они могут вкладываться в условные инструкции if, присутствовать в объявлениях функций def и так далее, и они не имеют никакого эффекта, пока интерпретатор не достигнет их в ходе выполнения программы. Другими словами, импортируемые модули и имена в них не будут доступны, пока не будут выполнены соответствующие инструкции import или from.  

Кроме того, подобно инструкции def, import и from – это явные операции присваивания:
 - Инструкция import присваивает объект модуля единственному имени.
 - Инструкция from присваивает одно или более имен объектам с теми же именами в другом модуле.  

Все, что уже обсуждалось ранее, в равной степени применимо и к модулям. Например, имена, копируемые инструкцией from, становятся ссылками на разделяемые объекты – как и в случае с аргументами функций, повторное присваивание полученному имени не оказывает воздействия на модуль, откуда это имя было скопировано, но модификация изменяемого объекта может оказывать
воздействие на объект в модуле, откуда он был импортирован. Для иллюстрации рассмотрим следующий файл small.py:

                                x = 1
                                y = [1, 2]

                                >>> from small import x, y # Скопировать два имени
                                >>> x = 42 # Изменяется только локальная переменная x
                                >>> y[0] = 42 # Изменяется непосредственно изменяемый объект

Здесь x не является разделяемым изменяемым объектом, а вот y – является. Имена y в импортирующем и импортируемом модулях ссылаются на один и тот же объект списка, поэтому изменения, произведенные в одном модуле, будут видны в другом модуле:  

                                >>> import small # Получить имя модуля (инструкция from его не дает)
                                >>> small.x # x в модуле small – это не моя переменная x
                                1
                                >>> small.y # Но изменяемый объект используется совместно
                                [42, 2]

**Изменение значений имен в других файлах**  
между именем, скопированным инструкцией from, и именем в файле, откуда это имя было скопировано, нет никакой связи. Чтобы действительно изменить глобальное имя в другом файле, необходимо использовать инструкцию import:  

                                >>> from small import x, y # Скопировать два имени
                                >>> x = 42 # Изменить только локальное имя x

                                >>> import small # Получить имя модуля
                                >>> small.x = 42 # Изменить x в другом модуле

Обратите внимание, что изменение элемента y[0] в предыдущем примере – это нечто иное; изменяется объект, а не имя.

