Фундаментальная идея программирования на языке Python, которая составляет основу гибкости языка – **динамическая типизация и полиморфизм**. Типы данных в языке Python определяются автоматически во время выполнения, а не в результате объявлений в программном коде.

Когда выполняется операция присваивания, такая как a = 3, интерпретатор выполняет ее, хотя перед этим ему нигде не сообщалось, что a – это имя переменной, или что она представляет объект целочисленного типа. В языке Python все решается весьма естественным способом, как описано ниже:

 - Создание переменной. Переменная (то есть имя), такая как a, создается автоматически, **когда в программном коде ей впервые присваивается некоторое значение**. Все последующие операции присваивания просто изменяют значение, ассоциированное с уже созданным именем. Строго говоря, интерпретатор Python определяет некоторые имена до запуска программного кода.

 - Типы переменных. Переменные не имеют никакой информации о типе или ограничениях, связанных с ним. Понятие типа присуще объектам, а не именам. Переменные универсальны по своей природе – **они всегда являются всего лишь ссылками на конкретные объекты в конкретные моменты времени**.

 - Использование переменной. Когда переменная участвует в выражении, ее имя замещается объектом, на который она в настоящий момент ссылается, независимо от того, что это за объект. Кроме того, прежде чем переменную можно будет использовать, ей должно быть присвоено значение – использование неинициализированной переменной приведет к ошибке.

Например, если ввести такую инструкцию:

                                            >>> a = 3
интерпретатор Python выполнит эту инструкцию в три этапа, по крайней мере, концептуально. Следующие этапы отражают все операции присваивания в языке Python:  
 1. Создается объект, представляющий число 3.  
 2. Создается переменная a, если она еще отсутствует.  
 3. В переменную a записывается ссылка на вновь созданный объект, представляющий число 3.

переменные и объекты хранятся в разных частях памяти и связаны между собой ссылкой. Переменные всегда ссылаются на объекты и никогда – на другие переменные, но крупные объекты могут ссылаться на другие объекты (например, объект списка содержит ссылки на объекты, которые включены в список).

В конкретных терминах:  
 - **Переменные** – это записи в системной таблице, где предусмотрено место для хранения ссылок на объекты.  
 - **Объекты** – это области памяти с объемом, достаточным для представления значений этих объектов.  
 - **Ссылки** – это автоматически разыменовываемые указатели на объекты.

Каждый объект имеет два стандартных поля:  
 - описатель типа, используемый для хранения информации о типе объекта
 - счетчик ссылок, используемый для определения момента, когда память, занимаемая объектом, может быть освобождена.

всякий раз, когда имя ассоциируется с новым объектом, интерпретатор Python освобождает память, занимаемую предыдущим объектом (если на него не ссылается какое-либо другое имя или объект). Такое автоматическое освобождение памяти, занимаемой объектами, называется сборкой мусора (garbage collection).  

                                            >>> x = 42  
                                            >>> x = 'spam'

Например, когда с именем x связывается строка 'spam', объект 42 немедленно уничтожается (при условии, что на него не ссылается никакое другое имя), а пространство памяти, занимаемое объектом, возвращается в пул свободной памяти для повторного использования в дальнейшем. Достигается это за счет того, что в каждом объекте имеется счетчик ссылок, с помощью которого интерпретатор следит за количеством ссылок, указывающих на объект в настоящий момент времени. Как только (и именно в этот момент) значение счетчика достигает нуля, память, занимаемая объектом, автоматически освобождается. 

### разделяемые ссылки  
посмотрим, что происходит с именами и объектами в этом случае:

                  >>> a = 3
                  >>> b = a

В результате выполнения этих двух инструкций получается схема взаимоотношений:

![img_1](https://user-images.githubusercontent.com/35499834/42133149-60cb18d6-7d2d-11e8-958b-57b4bded70dc.png)

Вторая инструкция вынуждает интерпретатор создать переменную b и использовать для инициализации переменную a,
при этом она замещается объектом, на который ссылается (3), и b превращается в ссылку на этот объект. В результате переменные a и b ссылаются на один и тот же объект (то есть указывают на одну и ту же область в памяти). В языке
Python это называется **разделяемая ссылка** – несколько имен ссылаются на один и тот же объект.

Далее добавим еще одну инструкцию:

                  >>> a = 3
                  >>> b = a
                  >>> a = 'spam'

Как во всех случаях присваивания в языке Python, в результате выполнения этой инструкции создается новый объект, представляющий строку 'spam', а ссылка на него записывается в переменную a. Однако эти действия не оказывают влияния на переменную b – она по-прежнему ссылается на первый объект, целое число 3. В результате схема взаимоотношений приобретает вид:  

![img_2](https://user-images.githubusercontent.com/35499834/42133174-e83fa00c-7d2d-11e8-916d-15e817fb5491.png)

То же самое произошло бы, если бы ссылка на объект ‘spam’ вместо переменной a была присвоена переменной b – изменилась бы только переменная b, но не a.  

Запись нового значения в переменную не приводит к изменению первоначального объекта, но приводит к тому, что переменная
начинает ссылаться на совершенно другой объект. В результате инструкция присваивания может воздействовать только на одну переменную.  

### Разделяемые ссылки и изменяемые объекты  

                  >>> L1 = [2, 3, 4]  
                  >>> L2 = L1  
                  >>> L1[0] = 24  

                  >>> L1  
                  [24, 3, 4]  

                  >>> L2  
                  [24, 3, 4]  

Поскольку объект списка разделяется разными переменными (ссылки на него находятся в разных переменных), то изменения в самом списке затрагивают не только L1, но также в переменной L2, потому что она ссылается на тот же самый объект, что
и L1. Здесь мы фактически не изменяли L2, но значение этой переменной изменилось.

!!! Получение среза не применимо с таким изменяемым типом как словарь - т.к. словарь не является последовательностью. Чтобы скопировать словарь - используется метод x.copy() Интерпретатор кэширует и повторно использует малые целые числа и небольшие строки. Однако большинство объектов уничтожаются немедленно, как только будет потеряна последняя ссылка.

**Оператор ==** - проверяет равны ли значения объектов. **Оператор is** - проверяет идентичность объектов, возвращает True только если оба имени ссылаются на один и тот же объект.  

                                    >>> L = [2, 3, 4]  
                                    >>> M = L

                                    >>> L == M
                                    True

                                    >>> L is M
                                    True

                                    >>> L = [1, 2, 3]  
                                    >>> M = [1, 2, 3]  

                                    >>> L == M  
                                    True  

                                    >>> L is M  
                                    False  

Фактически если вы действительно хотите взглянуть на работу внутренних механизмов, вы всегда можете запросить у интерпретатора количество ссылок на объект: функция getrefcount из стандартного модуля sys возвращает значение поля счетчика ссылок в объекте.  

                                    >>> import sys  
                                    >>> sys.getrefcount(1)
                                    132    