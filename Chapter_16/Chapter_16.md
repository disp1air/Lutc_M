**Основные концепции, составляющие основу функций:**
 - def относится к классу исполняемых инструкций – функция не существует, пока интерпретатор не доберется до инструкции def и не выполнит ее.  

 - Когда интерпретатор встречает и выполняет инструкцию def, он создает новый объект-функцию, в который упакует программный код функции и связывает его с именем функции. Как и в любой другой операции присваивания, имя становится ссылкой на объект-функцию. к функциям можно прикреплять различные атрибуты, определяемые пользователем, для сохранения каких-либо данных.

 - Выражение lambda создает объект и возвращает его в виде результата. Функции могут также создаваться с помощью выражения lambda. Это позволяет создавать встроенные определения функций там, где синтаксис языка не позволяет использовать инструкцию def  

 - return передает объект результата вызывающей программе. Когда функция вызывается, вызывающая программа приостанавливает свою работу, пока функция не завершит работу и не вернет управление.  

 - yield передает объект результата вызывающей программе и запоминает, где был произведен возврат. Функции, известные как генераторы, для передачи возвращаемого значения могут также использовать инструкцию yield и сохранять свое состояние так, чтобы работа функции могла быть возобновлена позднее.

 - Аргументы передаются посредством присваивания (в виде ссылок на объекты). Изменение имени аргумента также не изменяет имени в вызывающей программе, но модификация изменяемых объектов внутри функции может приводить к изменению объектов в вызывающей программе.
 
 - global объявляет переменные, глобальные для модуля, без присваивания им значений.  

 - nonlocal объявляет переменные, находящиеся в области видимости объемлющей функции, без присваивания им значений.

**Инструкция def создает объект функции и связывает его с именем**. В общем виде инструкция имеет следующий формат:

                                              def <name>(arg1, arg2,... argN):
                                                  <statements>

Когда интерпретатор достигнет инструкции def и выполнит ее, он создаст новый объект функции, в который упакует программный код функции и свяжет объект с именем.

Инструкция return может располагаться в любом месте в теле функции – она завершает работу функции и передает результат вызывающей программе. Инструкция return содержит объектное выражение, которое дает результат функции. Инструкция return является необязательной – если она отсутствует, работа функции завершается, когда поток управления достигает конца тела функции. С технической точки зрения, функция без инструкции return автоматически возвращает объект None.

Будучи инструкцией, def может появляться везде, где могут появляться инструкции, – даже внутри других инструкций. Допускается вкладывать определения функций внутрь инструкций if, что позволяет производить выбор между альтернативами:

                                              if test:
                                                  def func(): # Определяет функцию таким способом
                                                      ...
                                              else:
                                                  def func(): # Или таким способом
                                                      ...
                                                      ...
                                              func() # Вызов выбранной версии

Так как определение функции происходит во время выполнения, в именах функций нет ничего особенного. Важен только объект, на который ссылается имя:

                                              othername = func # Связывание объекта функции с именем
                                              othername() # Вызов функции

В этом фрагменте функция была связана с другим именем и вызвана уже с использованием нового имени. Как и все остальное в языке Python, функции это обычные объекты; они явно записываются в память во время выполнения программы.

Кроме поддержки возможности вызова, функции позволяют присоединять любые атрибуты, в которых можно сохранять информацию для последующего использования:  

                                              func.attr = value # Присоединяет атрибут к объекту

передача аргументов осуществляется за счет выполнения операции присваивания.

### Полиморфизм
полиморфизм – термин, который означает, что смысл операции зависит от типов обрабатываемых объектов. Фактически
все операции в языке Python являются полиморфическими: вывод, извлечение элемента, оператор * и многие другие.

при программировании на языке Python во внимание принимаются интерфейсы объектов, а не типы данных.  

Конечно, такая модель полиморфизма предполагает необходимость тестирования программного кода на наличие ошибок, так как из-за отсутствия объявлений типов нет возможности с помощью компилятора выявить некоторые виды ошибок на ранней стадии. 

Прежде чем функцию можно будет вызвать, ее необходимо создать. Для этого нужно выполнить инструкцию def, либо введя ее в интерактивной оболочке, либо поместив ее в файл модуля и выполнив операцию импорта. Как только инструкция def будет выполнена, можно будет вызывать функцию.
