* инструкция print была инструкцией в Python 2.6, а в Python 3.0 она стала функцией, поэтому круглые скобки являются  обязательным элементом только в версии 3.0

* если вы пользуетесь версией Python 2.6 или более ранней, используйте функцию raw_input() вместо функции input(). В Python 3.0 первая была переименована в последнюю. С технической точки зрения, версия 2.6 также имеет функцию input, но она интерпретирует вводимые строки, как если бы они содержали программный код, и потому она не может использоваться в данном контексте (ввод пустой строки вызывает ошибку). В Python 3.0 функция input (и raw_input в Python 2.6) просто возвращают введенный текст в виде строки, никак не интерпретируя их. Сымитировать поведение функции input из Python 2.6 в Python 3.0
можно с помощью конструкции eval(input()).

* встроенная функция reload, доступной в модуле imp из стандартной библиотеки (в Python 2.6 эта функция была обычной встроенной функцией, но в Python 3.0 она была перенесена в модуль imp)

* В версии 2.6 строки Юникода были представлены отдельным типом, а строки типа str могли содержать 8-битные символы и двоичные данные.

* в Python 2.X имеется метод (словаря?) has_key (который недоступен в версии 3.0);

* В Python 2.6 имеется два типа целых чисел: обычные (32-битные) и длинные (неограниченной точности). Если числовой литерал заканчивается символом l или L, он рассматривается интерпретатором как длинное целое число. Целые числа автоматически преобразуются в длинные целые, если их значения не умещаются в отведенные 32 бита, поэтому вам не требуется вводить символ L – интерпретатор автоматически выполнит необходимые преобразования, когда потребуется увеличить точность представления.

* В Python 3.0 обычные и длинные целые числа были объединены в один тип целых чисел, который автоматически поддерживает неограниченную точность, как длинные целые в Python 2.6. По этой причине теперь не требуется завершать литералы целых чисел символом l или L, и при выводе целых чисел этот символ никогда не выводится.

* В Python 2.6 и в более ранних версиях восьмеричные литералы могут начинаться только с символа 0 (без буквы «o»), но в версии 3.0 такая форма записи считается недопустимой (при использовании прежней формы записи восьмеричные числа легко можно перепутать с десятичными, поэтому была принята новая форма записи, когда восьмеричные литералы начинаются с комбинации символов 0o).

* В версии Python 2.6 неравенство значений можно проверить двумя способами, как X != Y или как X <> Y. В Python 3.0 последний вариант был убран. В обеих версиях рекомендуется использовать выражение X != Y для проверки на неравенство.

* Операция деления с округлением вниз (X // Y) всегда усекает дробную часть в обеих версиях Python 2.6 и 3.0. Операция деления X / Y в версии 3.0 выполняет истинное деление (возвращает результат с дробной частью), а в версии 2.6 – классическое деление (усекает результат до целого числа).

* В Python 2.X при выполнении операций сравнения числовые значения приводятся к общему типу, а упорядочение несовместимых типов выполняется посредством сравнивания имен типов значений и считается допустимым. В Python 3.0 не допускается сравнивать несовместимые типы, не являющиеся числами, а попытка такого сравнения вызывает исключение.

* В Python 2.6 допускается сравнивание разнотипных нечисловых значений, но при этом преобразование типов операндов не
выполняется (сравнивание разнотипных значений выполняется в соответствии с фиксированным, но достаточно произвольным
правилом). В версии 3.0 сравнивание разнотипных нечисловых значений не допускается и приводит к исключению.

* пользователи Python 2.6 должны помнить, что литералы восьмеричных чисел в этой версии начинаются с одного нуля – это первоначальный формат представления восьмеричных чисел в языке Python

* Сравнивание и сортировка в Python 3.0 и Python 2.6

* В версии 2.6 метод словаря keys конструирует и возвращает обычный список, в версии 3.0 метод keys возвращает итератор, а не список.

* В Python 2.6 словари могут сравниваться между собой с помощью операторов <, > и других, но в Python 3.x эта возможность больше не поддерживается.

* метод has_key словарей, выполняющий проверку наличия ключей, был ликвидирован в версии 3.0.

* Python 3.0 метод объекта файла write возвращает количество записанных символов – в версии 2.6 этого не происходит

* В версии Python 2.6 метод итераций называется X.next(), а не X.__next__().

* Режим работы интерпретатора Python 3.0 эквивалентен запуску интерпретатора версии 2.6 с ключом -tt.  

* В версии Python 3.0 появилась новая инструкция nonlocal  

* функции apply была ликвидирована в версии 3.0  

* В Python 3.0 (но не в 2.6) имеется также возможность присоединять к объектам функций краткое описание (аннотацию) – произвольные данные об аргументах функции и о возвращаемом значении.  

* Функция reduce в Python 2.6 была простой встроенной функцией, но в версии 3.0 она была перемещена в модуль functools и стала более сложной.  

* в Python 2.4 и в более ранних версиях предложение finally не может использоваться в той же инструкции try, где уже используется предложение except или else, поэтому форму try/finally лучше считать отдельной формой инструкции при работе со старыми версиями. Однако в Python 2.5 предложение finally может присутствовать в инструкции try вместе с предложениями except и else, поэтому в настоящее время существует единая инструкция try, которая может употребляться с несколькими необязательными предложениями.  

* В Python 3.0 (но не в 2.6) инструкция raise может также включать дополнительное предложение from.