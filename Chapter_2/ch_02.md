Когда интерпретатор Python получает команду запустить сценарий, он выполняет несколько промежуточных действий, прежде чем ваш программный код начнет «скрипеть колесами». Сценарий сначала будет скомпилирован в нечто под названием «байт-код», а затем передан механизму, известному под названием «виртуальная машина».  

PVM - это просто большой цикл, который выполняет перебор инструкций в байт-коде, одну за одной, и выполняет соответствующие им операции.

PVM – это механизм времени выполнения, она всегда присутствует в составе системы Python и это тот самый программный компонент, который выполняет ваши сценарии.  

sys.platform – это просто строковая переменная, содержимое которой идентифицирует тип компьютера, на котором выполняется сценарий.  

Можно перенаправить вывод сценария Python в файл, чтобы детально исследовать полученные результаты позднее, как показано ниже:  

                    % python script1.py > saveit.txt

В этом случае три строки, которые были показаны в предыдущем примере запуска сценария, не будут выводиться на экран, а будут записаны в файл saveit.txt. Это широко известная возможность перенаправления потоков – она мо-
жет использоваться как для вывода текста, так и для ввода.  

**Инструкция import требует, чтобы путь к файлу и его расширение были опущены (например, import script1)**  

функция input – это средство для ввода информации; она дополняет инструкцию print, которая является средством вывода. Она представляет собой простейший способ чтения данных, вводимых пользователем. Например, функция input:
 - Может принимать строку в качестве аргумента, которая будет выводиться как подсказка (например, input(‘Press Enter to exit’))
 - Возвращает сценарию текстовую строку (например, nextinput = input())
 - Поддерживает возможность перенаправления ввода на уровне командной оболочки системы (например, python spam.py < input.txt), точно так же, как инструкция print поддерживает возможность перенаправления вывода  

### Импортирование и перезагрузка модулей  
Интересный факт, что операция импорта на заключительном этапе приводит к выполнению программного кода загружаемого файла.  

                    >>import script1

Как следствие, импорт файла является еще одним способом запустить его. Такой способ пригоден только для однократного запуска модуля в течение сеанса. После первой операции импорта все последующие попытки импортировать модуль не приводят ни к каким результатам, даже если изменить и сохранить исходный текст модуля в другом окне.  

Так сделано преднамеренно – операция импорта требует слишком больших затрат вычислительных ресурсов, чтобы выполнять ее более одного раза в ходе выполнения программы. В ходе импорта производится поиск файлов, компиляция их в байт-код и выполнение этого байт-кода.  

**Функция reload()**  

### Важные сведения о модулях: атрибуты  
Модуль – это, главным образом, всего лишь пакет имен переменных, известный как **пространство имен**. Имена внутри этого пакета называются атрибутами, то есть атрибут – это имя переменной, которая связана с определенным объектом (таким как модуль).  

Инструкция from во многом подобна инструкции import, которая выполняет присваивание имен в импортируемом компоненте.
С технической точки зрения, инструкция from копирует атрибуты модуля так, что они становятся простыми переменными в программном коде, выполняющем импорт, благодаря чему на этот раз он может обратиться к импортированной строке уже не по имени myfile.title (ссылка на атрибут), а просто – title (переменная)  

необходимо отметить, что инструкция from в некотором смысле стирает границы пространств имен между модулями, потому что она копирует переменные из одного файла в другой. Это может вызывать затирание переменных в импортирующем файле одноименными переменными в импортируемом файле (при этом никаких предупреждений выводиться не будет). По сути, эта инструкция выполняет разрушительное объединение пространств имен, по крайней мере, в терминах копируемых переменных. По этой причине многие рекомендуют использовать инструкцию import вместо from.

Инструкция import выполняет файл только один раз за все время выполнения программы и создает отдельное пространство имен модуля, поэтому подобные операции присваивания не приводят к затиранию значений переменных в импортирующем программном коде

??? транзитивная операция

интерпретатор Python выполняет поиск импортируемых модулей во всех каталогах, перечисленных в переменной sys.path, – в списке имен каталогов, определенном в модуле sys, который инициализируется значением переменной окружения PYTHONPATH, и в наборе стандартных имен каталогов. Если возникает потребность импортировать модули из других каталогов, отличных от того, в котором вы работаете, они должны быть перечислены в переменной PYTHONPATH.  

