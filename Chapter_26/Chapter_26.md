В объектно-ориентированной модели языка Python существует две разновидности объектов: объекты классов и объекты экземпляров. Объекты классов реализуют поведение по умолчанию и играют роль фабрик по производству объектов экземпляров. Объекты экземпляров – это настоящие объекты, обрабатываемые программой, – каждый представляет собой самостоятельное пространство имен, но наследует имена (то есть автоматически имеет доступ к ним) класса, из которого он был создан.

Объекты классов создаются инструкциями, а объекты экземпляров – вызовами. Каждый раз, когда вы вызываете класс, вы получаете новый экземпляр этого класса.

Функции внутри классов обычно называются методами. Это обычные инструкции def. Но в первом аргументе методы автоматически получают подразумеваемый объект экземпляра – контекст вызова метода.  

                                      class FirstClass:
                                          def setdata(self, value):
                                              self.data = value

                                          def display(self):
                                              print(self.data)

                                      x = FirstClass()
                                      y = FirstClass()  

                                      x.setdata(“King Arthur”)
                                      y.setdata(3.14159)

                                      x.display()
                                      King Arthur

                                      y.display()
                                      3.14159

Еще один способ, дающий возможность оценить, насколько динамична эта модель, позволяет изменять атрибуты экземпляров в самом классе, выполняя присваивание как с помощью аргумента self внутри методов, так и за пределами класса, когда экземпляр явно участвует в операции присваивания:  

                            x.data = “New value” # Можно получать/записывать значения атрибутов
                            x.display() # И за пределами класса тоже
                            New value

Обычно классы создают все атрибуты экземпляров за счет присваивания значений аргументу self, но это не обязательно – программы могут получать, изменять или создавать атрибуты в любых объектах, к которым они имеют доступ.

Суперклассы перечисляются в круглых скобках в заголовке инструкции class. Чтобы унаследовать атрибуты другого класса, достаточно указать этот класс в круглых скобках в заголовке инструкции class. Наследующий класс называется подклассом, а наследуемый класс называется его суперклассом.

Согласно общепринятым соглашениям, имена классов в языке Python должны начинаться с заглавной буквы, чтобы обеспечить визуальное отличие.  

**Классы могут переопределять операторы языка Python**  
Говоря простым языком, перегрузка операторов позволяет объектам, созданным из классов, перехватывать и участвовать в операциях, которые применяются к встроенным типам: сложение, получение среза, вывод, квалификация имен и так далее. По большей части это автоматический механизм: при выполнении выражений и других встроенных операций интерпретатор передает управление реализации классов. В модулях нет ничего подобного: модули могут реализовать функции, но не операторы выражений.

Перегрузка операторов в языке Python реализуется за счет создания методов со специальными именами для перехватывания операций. Такие методы вызываются автоматически, когда экземпляр участвует во встроенных операциях. Например, если объект экземпляра наследует метод \_\_add__, этот метод будет вызываться всякий раз, когда объект будет появляться в операции сложения (+). Возвращаемое значение метода становится результатом соответствующей операции.

Классы могут переопределять большинство встроенных операторов.  

В методах перегрузки операторов не существует аргументов со значениями по умолчанию, и ни один из таких методов не является обязательным для реализации. Если класс не определяет и не наследует методы перегрузки операторов, это означает лишь, что экземпляры класса не поддерживают эти операции. Например, если отсутствует метод \_\_add__, попытка выполнить операцию сложения + будет приводить к возбуждению исключения.  

Метод \_\_add__ вызывается, когда экземпляр ThirdClass участвует в операции +
Метод \_\_str__ вызывается при выводе объекта (точнее, когда он преобразуется в строку для вывода вызовом встроенной функции str или ее эквивалентом внутри интерпретатора). проще говоря - \_\_str__ вызывается всякий раз, когда экземпляр преобразуется в строку для вывода.  

**О thirdExample:**  
При выполнении операции сложения объект экземпляра слева от оператора передается методу \_\_add__ в виде аргумента self,а значение справа – в виде аргумента other. Независимо от того, что вернет метод \_\_add__, это значение будет интерпретироваться, как результат операции сложения.

![img_1](https://user-images.githubusercontent.com/35499834/44537470-94ed7600-a707-11e8-9ff9-3b449d5846e9.png)  

Когда объект участвует в вызове функции print, интерпретатор вызывает метод \_\_str__ объекта и передает ему сам объект – любая строка, которую вернет этот метод, будет расцениваться, как строковое представление объекта для вывода. 

Следующая инструкция создает класс без присоединенных к нему атрибутов (объект пустого пространства имен):  

                                            class rec: pass

Инструкция пустой операции pass необходима потому, что здесь у нас нет никаких методов с программным кодом.  

После создания класса, выполнив инструкцию в интерактивной оболочке, мы можем приступать к присоединению атрибутов, выполняя операции присваивания из-за пределов класса:  

                                            rec.name = ‘Bob’
                                            rec.age = 40  

После того как атрибуты будут созданы, мы можем обращаться к ним с помощью обычного синтаксиса.

Классы – это полноценные объекты, даже если нет ни одного экземпляра. Фактически они всего лишь самостоятельные пространства имен, поэтому, пока у нас имеется ссылка на класс, мы можем в любое время добавлять или изменять его атрибуты по своему усмотрению. Однако посмотрим, что произойдет, когда будут созданы два экземпляра класса:

                                            x = rec() # Экземпляры наследуют имена из класса
                                            y = rec()  

Эти экземпляры начинают свое существование как объекты абсолютно пустых пространств имен. Однако из-за того, что они помнят класс, из которого были созданы, они по наследству получат атрибуты, которые мы присоединили к классу:  

                                            x.name, y.name # Сейчас имена хранятся только в классе
                                            (‘Bob’, ‘Bob’)  

В действительности у этих экземпляров нет собственных атрибутов – они просто получают атрибут name из класса. Тем не менее если выполнить присваивание атрибуту экземпляра, будет создан (или изменен) атрибут этого объекта, а не другого – атрибуты обнаруживаются в результате поиска по дереву наследования, но операция присваивания значения атрибуту воздействует только на
тот объект, к которому эта операция применяется. Ниже экземпляр x получает свой собственный атрибут name, а экземпляр y по-прежнему наследует атрибут name, присоединенный к классу выше его:  

                                            x.name = ‘Sue’ # Но присваивание изменит только объект x
                                            rec.name, x.name, y.name
                                            (‘Bob’, ‘Sue’, ‘Bob’)

атрибуты объекта пространства имен обычно реализованы в виде словарей, и деревья наследования классов (вообще говоря) тоже всего лишь словари со ссылками на другие словари.  

**\_\_dict__** : в большинстве объектов, созданных на базе классов, имеется атрибут \_\_dict__, который является словарем пространства имен.  

                                          rec.\_\_dict__.keys()
                                          ['\_\_module__', 'name', 'age', '\_\_dict__', '\_\_weakref__', '\_\_doc__']

                                          list(x.\_\_dict__.keys())
                                          ['name']

                                          list(y.\_\_dict__.keys())
                                          []

Здесь в словаре класса присутствуют атрибуты name и age, которые мы создали ранее, объект x имеет свой собственный атрибут name, а объект y по-прежнему пуст.

\_\_class__ :  каждый экземпляр имеет ссылку на свой наследуемый класс, она называется \_\_class__  

                                          x.\_\_class__
                                          <class \_\_main__.rec>

\_\_bases__ : классы также имеют атрибут \_\_bases__, который представляет собой кортеж его суперклассов. 

                                          >>> rec.\_\_bases__
                                          (<class ‘object’>,)

модель классов в языке Python чрезвычайно динамична. Классы и экземпляры – это всего лишь объекты пространств имен с атрибутами, создаваемыми на лету с помощью операции присваивания. Обычно эти операции присваивания выполняются внутри инструкции class, но они могут находиться в любом другом месте, где имеется ссылка на один из объектов в дереве.

Даже методы, которые обычно создаются инструкциями def, вложенными в инструкцию class, могут создаваться совершенно независимо от объекта класса.  

                                          def upperName(self):
                                              return self.name.upper()  

                                          upperName(x)
                                          ‘SUE’

Однако, если эту простую функцию присвоить атрибуту класса, она станет методом, вызываемым из любого экземпляра (а также через имя самого класса при условии, что функции вручную будет передан экземпляр)(Фактически это одна из причин, почему в языке Python аргумент self всегда должен явно объявляться в методах, – потому что методы могут создаваться как простые
функции, независимо от классов, и им необходим явный аргумент со ссылкой на подразумеваемый экземпляр. В противном случае интерпретатор не смог бы обеспечить превращение простой функции в метод класса. Однако основная причина, по которой аргумент self объявляется явно, заключается в том, чтобы сделать назначение имен более очевидным. Имена, к которым обращаются не через аргумент self, являются простыми переменными, тогда как имена, обращение к которым происходит
через аргумент self, очевидно являются атрибутами экземпляра.):  

                                          rec.method = upperName
                                          x.method() # Вызвать метод для обработки x
                                          ‘SUE’

                                          y.method() # То же самое, но в self передается y
                                          ‘BOB’

                                          >>> rec.method(x) # Можно вызвать через имя экземпляра или класса
                                          ‘SUE’  

Обычно заполнение классов производится внутри инструкции class, а атрибуты экземпляров создаются в результате присваивания значений атрибутам аргумента self в методах. Однако, все это не является обязательным, поскольку ООП в языке Python – это в основном поиск атрибутов во взаимосвязанных объектах пространств имен.

Фактически у экземпляров одного и того же класса не обязательно должны быть одинаковые наборы имен атрибутов.  