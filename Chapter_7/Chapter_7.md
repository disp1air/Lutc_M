Строки - упорядоченные последовательности символов, используемые для хранения и представления текстовой информации.
языке Python отсутствует специальный тип для представления единственного символа, поэтому в случае необходимости используются односимвольные строки. строки в языке Python относятся к категории неизменяемых последовательностей.

В Python 3.0 существует три строковых типа: str – для представления текста Юникода (содержащего символы в кодировке
ASCII и символы в других кодировках), bytes – для представления двоичных данных (включая кодированный текст) и bytearray
– изменяемый вариант типа bytes.

Кавычки и апострофы, окружающие строки, в языке Python являются взаимозаменяемыми. То есть строковые литералы можно заключать как в апострофы, так и в кавычки – эти две формы представления строк ничем не отличаются, и обе они возвращают объект того же самого типа.

Причина наличия двух вариантов состоит в том, чтобы позволить вставлять в литералы символы кавычек и апострофов, не используя для этого символ обратного слеша. Вы можете вставлять апострофы в строки, заключенные в кавычки, и наоборот:

Python автоматически объединяет последовательности строковых литералов внутри выражения:

                                    >>> title = "men " 'in' " black"
                                    >>> title
                                    'men in black'

Если между этими строками добавить запятые, то будет получен кортеж, а не строка.

Кавычки и апострофы можно вставлять в строки, экранируя их символом обратного слеша:

                                    >>> 'knight\'s', "knight\"s"
                                    ("knight's", 'knight"s')

**Экранированные последовательности представляют служебные символы**  
символы обратного слеша используются для вставки специальных символов, известных как экранированные последовательности.
Экранированные последовательности позволяют вставлять в строки символы, которые сложно ввести с клавиатуры. В конечном строковом объекте символ \ и один или более следующих за ним символов замещаются единственным символом, который имеет двоичное значение, определяемое экранированной последовательностью.

Последовательность \n образует единственный символ – байт, содержащий двоичное значение кода символа новой строки в используемом наборе символов (обычно ASCII-код 10).

Некоторые экранированные последовательности позволяют указывать абсолютные двоичные значения в байтах строк. Например, ниже приводится пример строки из пяти символов, содержащей два нулевых байта:

                                    >>> s = 'a\0b\0c'
                                    >>> s
                                    'a\x00b\x00c'

                                    >>> len(s)
                                    5

Ниже приводится строка, полностью состоящая из экранированных кодов, – двоичные значения 1 и 2 (записаны в восьмеричной форме), за которыми следует двоичное значение 3 (записано в шестнадцатеричной форме):

                                    >>> s = '\001\002\x03'
                                    >>> s
                                    '\x01\x02\x03'

                                    >>> len(s)
                                    3

что интерпретатор Python отображает непечатаемые символы в шестнадцатеричном представлении, независимо от того, в каком виде
они были указаны внутри литерала.

**Неформатированные строки подавляют экранирование.**  
Если перед кавычкой, открывающей строку, стоит символ r (в верхнем или в нижнем регистре), он отключает механизм экранирования. В результате интерпретатор Python будет воспринимать символы обратного слеша в строке как обычные символы.

                                    myfile = open(r'C:\new\text.dat', 'w')

Как вариант, учитывая, что два идущих подряд символа обратного слеша интерпретируются как один символ, можно просто продублировать символы обратного слеша:

                                    myfile = open('C:\\new\\text.dat', 'w')

Несмотря на свое предназначение, даже неформатированная строка не может заканчиваться единственным символом обратного слеша, потому что обратный слеш в этом случае будет экранировать следующий за ним символ кавычки – вы по-прежнему должны экранировать кавычки внутри строки. То есть конструкция r"...\" не является допустимым строковым литералом – неформатированная строка не может заканчиваться нечетным количеством символов обратного слеша.

Если необходимо, чтобы неформатированная строка заканчивалась символом обратного слеша, можно добавить два символа и затем удалить второй из них (r'1\nb\tc\\'[:-1]), добавить один символ вручную (r'1\nb\tc' + '\\') или использовать обычный синтаксис строковых литералов и дублировать все символы обратного слеша ('1\\nb\\tc\\'). Во всех трех случаях получается одна и та же строка из восьми символов, содержащая три обратных слеша.

**Тройные кавычки**  
Если вам потребуется отключить несколько строк программного кода и запустить сценарий снова, просто вставьте по три
кавычки до и после нужного блока кода.

                                    X = 1
                                    """
                                    import os
                                    print(os.getcwd())
                                    """
                                    Y = 2

В случае крупных блоков программного кода использовать этот прием гораздо удобнее, чем вставлять символы решетки в начале каждой строки, а затем убирать их.

**Базовые операции**
                                    >>> 'abc' + 'def' # Конкатенация: новая строка
                                    'abcdef'
                                    >>> 'Ni!' * 4
                                    'Ni!Ni!Ni!Ni!'

интерпретатор не позволяет смешивать строки и числа в выражениях сложения: 'abc' + 9 вызовет ошибку вместо того, чтобы автоматически преобразовать число 9 в строку.

допускается выполнять обход элементов строки в цикле, используя инструкцию for, и проверять вхождение подстроки в строку с помощью оператора выражения in, который, по сути, выполняет операцию поиска.

**Доступ по индексам и извлечение подстроки**
Технически отрицательное смещение складывается с длиной строки, чтобы получить положительное смещение. Отрицательные смещения можно также представить себе как отсчет символов с конца строки.

                                    >>> S = 'spam'
                                    >>> S[1:3], S[1:], S[:-1]
                                    ('pa', 'pam', 'spa')

самый левый элемент имеет смещение 0, а самый правый имеет смещение –1.

Как же выполняется операция получения среза? Когда производится индексирование объекта последовательности, такого как строка, парой смещений, разделенных двоеточием, интерпретатор Python возвращает новый объект, содержащий непрерывную область, определяемую парой смещений. Значение смещения слева от двоеточия обозначает левую границу (включительно),
а справа – верхнюю границу (она не входит в срез). Интерпретатор извлекает все элементы от нижней границы до верхней, но верхняя граница в срез не включается. Если левая и правая граница опущены, по умолчанию принимаются значения, равные 0 и длине объекта соответственно, из которого извлекается срез.

**Расширенная операция извлечения подстроки: третий предел.** Необязательный третий индекс используется как шаг. X[1:10:2] - вернет каждый второй элемент последовательности X в диапазоне смещений от 1 до 9 - т.е. будут выбраны элементы со смещениями 1, 3, 5, 7 и 9. если шаг отрицательный, то срез будет выведен в обратном порядке:

                                    >>> s = 'hello'
                                    >>> s[::-1]
                                    'olleh'

также порядок применения первых двух границ меняется на противоположный: т.е. S[5:1:-1] - извлечет элементы со 2 по 5 в обратном порядке.

**Инструменты преобразования строк**

                                    >>> '42' + 1
                                    TypeError

В соответствии с архитектурой языка оператор + может означать и операцию сложения, и операцию конкатенации, вследствие чего выбор типа преобразования становится неочевидным. Поэтому интерпретатор воспринимает такую инструкцию как ошибочную.

В этом случае следует использовать инструменты преобразования, чтобы можно было интерпретировать строку как число или наоборот.

                                    >>> str(42)
                                    '42'

                                    >>> int("42")
                                    42

Существуют похожие встроенные функции для преобразования вещественных чисел в/из строки:

                                    >>> str(3.1415), float("1.5")
                                    ('3.1415', 1.5)

Функции int и float преобразуют только числа, но это ограничение означает, что они обычно выполняют эту работу быстрее (и безопаснее, потому что они не принимают программный код произвольного выражения).

**Преобразование кодов символов**  
Имеется также возможность выполнить преобразование одиночного символа в его целочисленный код ASCII, для чего нужно передать этот символ функции ord – она возвращает фактическое числовое значение соответствующего байта в памяти. Обратное преобразование выполняется с помощью функции chr, она получает целочисленный код ASCII и преобразует его в соответствующий символ:

                                    >>> ord('s')
                                    115

                                    >>> chr(115)
                                    's'

Следующий пример преобразования представляет собой альтернативу встроенной функции int, по крайней мере для односимвольных строк, для преобразования строки в целое число:

                                    >>> int('5')
                                    5

                                    >>> ord('5') - ord('0')
                                    5



В действительности объекты типа bytearray не являются строками – это последовательности 8-битных целых чисел. Однако они поддерживают большую часть строковых операций и при отображении выводятся как строки символов ASCII. Объекты этого типа обеспечивают возможность хранения больших объемов текста, который требуется изменять достаточно часто.

**Строковые методы**
Методы – это просто функции, которые связаны с определенными объектами. Формально они являются атрибутами, присоединенными к объектам, которые ссылаются на функции.  

Если говорить более точно, функции – это пакеты программного кода, а вызовы методов объединяют в себе выполнение двух операций (извлечение атрибута и вызов функции).

Метод **replace** принимает в качестве аргумента оригинальную подстроку(любой длины) и строку (любой длины) замены, и выполняет глобальный поиск с заменой. Можно передать третий аргумент, который определяет число производимых замен:

                                    >>> 'aa$bb$cc$dd'.replace('$', 'SPAM')
                                    'aaSPAMbbSPAMccSPAMdd'

                                    >>> S.replace('SPAM', 'EGGS', 1) # Заменить одну подстроку
                                    'xxxxEGGSxxxxSPAMxxxx'

Метод **find** возвращает смещение, по которому найдена подстрока (по умолчанию поиск начинается с начала строки), или значение -1, если искомая подстрока не найдена.

Если в сценарии производится множество изменений длинных строк, вы можете повысить производительность сценария, преобразовав
строку в объект, который допускает внесение изменений:

                                    >>> S = 'spammy'
                                    >>> L = list(S)
                                    >>> L
                                    ['s', 'p', 'a', 'm', 'm', 'y']

Встроенная функция list (или функция-конструктор объекта) создает новый список из элементов любой последовательности – в данном случае «разрывая» строку на символы и формируя из них список. Обладая строкой в таком представлении, можно производить необходимые изменения, не вызывая создание новой копии строки при каждом изменении:  

                                    >>> L[3] = 'x' # Этот прием допустим для списков, но не для строк
                                    >>> L[4] = 'x'
                                    >>> L
                                    ['s', 'p', 'a', 'x', 'x', 'y']

Если после внесения изменений необходимо выполнить обратное преобразование, можно использовать метод **join**, который «собирает» список обратно в строку:

                                    >>> S = ''.join(L)
                                    >>> S
                                    'spaxxy'

Метод join вызывается через указание желаемой строки-разделителя. Метод join объединяет строки из списка, вставляя строку-разделитель между элементами списка.

                                    >>> 'SPAM'.join(['eggs', 'sausage', 'ham', 'toast'])
                                    'eggsSPAMsausageSPAMhamSPAMtoast'

Строковый метод **split** преобразует строку в список подстрок, окружающих строки-разделители.  

                                    >>> line = 'aaa bbb ccc'
                                    >>> cols = line.split()
                                    >>> cols
                                    ['aaa', 'bbb', 'ccc']

                                    >>> line = 'bob,hacker,40'
                                    >>> line.split(',')
                                    ['bob', 'hacker', '40']

                                    >>> line = "The knights who say Ni!\n"
                                    >>> line.rstrip()
                                    'The knights who say Ni!'

                                    >>> line.upper()
                                    'THE KNIGHTS WHO SAY NI!\n'

                                    >>> line.isalpha()
                                    False

                                    >>> line.endswith('Ni!\n')
                                    True

                                    >>> line.startswith('The')
                                    True

операции форматирования строк могут выполняться двумя способами:
 - Выражения форматирования строк
 - Метод форматирования строк

**Выражения форматирования строк**  

операции форматирования строк позволяют выполнять подстановку в строки значений различных типов за одно действие.

В языке Python имеется двухместный оператор %, предназначенный для работы со строками (что для чисел он является оператором
деления по модулю, или получения остатка от деления). Когда этот оператор применяется к строкам, он обеспечивает простой способ форматирования значений, согласно заданной строке формата.  

Чтобы отформатировать строку, требуется:
1. Слева от оператора % указать строку формата, содержащую один или более спецификаторов формата, каждый из которых начинается с символа % (например, %d).

2. Справа от оператора % указать объект (или объекты, в виде кортежа), значение которого должно быть подставлено на место спецификатора (или спецификаторов) в левой части выражения.

                                    >>> 'That is %d %s bird!' % (1, 'dead')
                                    That is 1 dead bird!

Обратите внимание: когда вставляется более одного значения, в правой части выражения их необходимо сгруппировать с помощью круглых скобок (то есть создать из них кортеж). Оператор форматирования % ожидает получить справа либо один объект, либо кортеж объектов.  

                                    >>> "%d %s %d you" % (1, 'spam', 4)
                                    '1 spam 4 you'

Объекты любого типа могут быть преобразованы в строку (это происходит, например, при выводе на экран), поэтому для любого
объекта может быть указан спецификатор %s.

Имейте в виду, что выражение форматирования всегда создает новую строку, а не изменяет строку, расположенную в левой части. Поскольку строки являются неизменяемыми, этот оператор вынужден работать именно таким способом.

