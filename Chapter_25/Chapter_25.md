Основное назначение классов состоит в том, чтобы создавать и манипулировать новыми объектами, а кроме того, они поддерживают механизм наследования.  

В отличие от других программных компонентов классы имеют три важных отличия:
 - **Множество экземпляров** - классы по своей сути являются фабриками по созданию объектов. Каждый раз, когда вызывается класс, создается новый объект со своим собственным пространством имен. Каждый объект, созданный из класса, имеет доступ
 к атрибутам класса и получает в свое распоряжение собственное пространство имен для своих собственных данных, отличных от данных других объектов.  
 - **Адаптация через наследование** - классы также поддерживают такое понятие ООП, как наследование, – мы можем расширять возможности класса, переопределяя его атрибуты за пределами самого класса.  
 - **Перегрузка операторов** - обеспечивая специальный протокол оформления методов, классы могут определять объекты, над которыми можно производить какие-то из операций, которые мы знаем по работе со встроенными типами. Например, объекты, созданные из классов, могут подвергаться операции извлечения среза, конкатенации, извлечения элементов по их индексам и так далее. Язык Python предоставляет специальные обработчики, которые могут использоваться классами для перехвата и реализации любой встроенной операции.  

Найти первое вхождение атрибута attribute, просмотрев объект object, а потом все классы в дереве наследования выше него, снизу вверх и слева направо.

Другими словами, выборка атрибутов производится в результате простого поиска по дереву. Мы называем эту процедуру поиском в дереве наследования, потому что объекты, расположенные в дереве ниже, наследуют атрибуты, имеющиеся у объектов, расположенных в дереве выше. Так как поиск происходит в направлении снизу вверх, объекты в некотором смысле оказываются
связаны в древовидную структуру, представляющую собой объединение всех атрибутов, определяемых всеми их родителями в дереве.

**Создание деревьев классов**  
 - Каждая инструкция class создает новый объект класса.
 - Каждый раз, когда вызывается класс, он создает новый объект экземпляра.
 - Экземпляры автоматически связываются с классами, из которых они были созданы.
 - Классы связаны со своими суперклассами, перечисленными в круглых скобках в заголовке инструкции class, – порядок следования в списке определяет порядок расположения в дереве.

                                    class C2: ... # Создать объекты классов (овалы)
                                    class C3: ...
                                    class C1(C2, C3): ... # Связанные с суперклассами
                                    I1 = C1() # Создать объекты экземпляров (прямоугольники),
                                    I2 = C1() # связанные со своими классами

Экземпляры помнят класс, из которого они были созданы, а класс C1 помнит о своих суперклассах.

С функциональной точки зрения, когда инструкция def появляется внутри инструкции class, она обычно называется методом и автоматически принимает специальный первый аргумент с именем self, который содержит ссылку на обрабатываемый экземпляр.

Так как классы являются фабриками, способными производить множество экземпляров, их методы обычно используют этот, получаемый автоматически, аргумент self для получения или изменения значений атрибутов конкретного экземпляра, который обрабатывается методом.  

Подобно простым переменным, атрибуты классов и экземпляров не объявляются заранее, а появляются, когда им впервые выполняется присваивание значений. Когда метод присваивает значение атрибуту с помощью имени self, он тем самым создает атрибут экземпляра, находящегося в нижнем уровне дерева классов потому что имя self автоматически ссылается на обрабатываемый экземпляр.  

Если в классе потребуется гарантировать, что атрибут, такой как name, всегда будет присутствовать в экземплярах, то такой атрибут должен создаваться на этапе создания класса, как показано ниже:

                                    class C1(C2, C3):
                                        def __init__(self, who):
                                            self.name = who

                                    I1 = C1('bob')
                                    I2 = C1('mel')
                                    I1.name
                                    'bob'  

В этом случае интерпретатор Python автоматически будет вызывать метод с именем \_\_init__ каждый раз при создании экземпляра класса. Новый экземпляр будет передаваться методу \_\_init__ в виде первого аргумента self, а любые значения, перечисленные в круглых скобках при вызове класса, будут передаваться во втором и последующих за ним аргументах. 
Метод \_\_init__ известен как конструктор, так как он запускается на этапе конструирования экземпляра.  

С фундаментальной точки зрения, классы – это действительно всего лишь пакеты функций и других имен, которые во многом напоминают модули. Однако автоматический поиск атрибутов в дереве наследования, который мы получаем при использовании классов, обеспечивает возможности по адаптации программного обеспечения более широкие, чем это возможно с помощью модулей
и функций.  