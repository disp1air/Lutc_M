**Свойства кортежей:**  
 - упорядоченные коллекции объектов произвольных типов    
 - Обеспечивают доступ к элементам по смещению  
 - Относятся к категории неизменяемых последовательностей  
 - Имеют фиксированную длину, гетерогенны и поддерживают произвольное число уровней вложенности
 - Массивы ссылок на объекты. Подобно спискам, кортежи проще представлять, как массивы ссылок на объекты, – кортежи хранят указатели (ссылки) на другие объекты, а операция индексирования над кортежами выполняется очень быстро.

Поскольку круглые скобки могут также окружать выражения, необходимо что-то предпринять, чтобы дать интерпретатору понять, что единственный объект в круглых скобках – это кортеж, а не простое выражение. Если необходимо получить кортеж с единственным элементом, нужно просто добавить запятую после этого элемента, перед закрывающей круглой скобкой, иначе это будет число:

                                        >>> T = (3,)
                                        >>> X = (3)
                                        
                                        >>> type(T)
                                        <class 'tuple'>

                                        >>> type(X)
                                        <class 'int'>

В виде исключения при определении кортежей интерпретатор позволяет опускать открывающую и закрывающую круглые скобки, если синтаксически конструкция интерпретируется однозначно.

                                      T = 0, 'Ni', 1.2, 3

В контексте операции присваивания интерпретатор распознает, что это кортеж, даже при отсутствии круглых скобок.

Единственное место, где круглые скобки являются обязательными, – при передаче кортежей функциям в виде литералов (где круглые скобки имеют важное значение)

??? Несмотря на отличия в синтаксисе литералов, операции, выполняемые над кортежами идентичны операциям, применяемым к строкам и спискам. Единственное отличие состоит в том, что операции +, * и извлечения среза при применении к кортежам возвращают новые кортежи.

Если, к примеру, необходимо отсортировать содержимое кортежа, его сначала следует преобразовать в список, чтобы
превратить в изменяемый объект и получить доступ к методу сортировки или задействовать новую функцию sorted, которая принимает объекты любых типов последовательностей (и не только).

**list и tuple** – это встроенные функции, которые используются для преобразования в список и затем обратно в кортеж. В действительности обе функции создают новые объекты, но благодаря им создается эффект преобразования.  

                                        >>> T = ('cc', 'aa', 'dd', 'bb')  
                                        >>> tmp = list(T)  # создать список из элементов кортежа
                                        >>> t1 = tuple(tmp)
                                        >>> t1  
                                        ('cc', 'aa', 'dd', 'bb')  

Для преобразования кортежей можно также использовать генераторы списков. Генераторы списков могут применяться даже к программным компонентам, которые физически не являются последовательностями, – к любым объектам, поддерживающим возможность
выполнения итераций, включая файлы, которые автоматически читаются строка за строкой.

                                        >>> T = (1, 2, 3, 4, 5)
                                        >>> L = [x + 20 for x in T]
                                        >>> L
                                        [21, 22, 23, 24, 25]

Кортежи обладают всего двумя методами – index и count, которые действуют точно так же, как одноименные методы списков:

                                        >>> T = (1, 2, 3, 2, 4, 2)  
                                        >>> T.index(2) # Первое вхождение находится в позиции 2  
                                        1  
                                        >>> T.index(2, 2) # Следующее вхождение за позицией 2  
                                        3  
                                        >>> T.count(2) # Определить количество двоек в кортеже  
                                        3  

**следует заметить, что правило неизменяемости применяется только к самому кортежу, но не к объектам, которые он содержит.**  

существуют ситуации, в которых кортежи можно использовать, а списки – нет. Например, в качестве ключей словаря.  

### Файлы  
встроенная функция open создает объект файла, который обеспечивает связь с файлом, размещенным в компьютере. После вызова функции open можно выполнять операции чтения и записи во внешний файл, используя методы полученного объекта.  

Объекты файлов выглядят несколько необычно. Они не являются ни числами, ни последовательностями или отображениями – для задач работы с файлами предоставляют одни только методы.  

**Открытие файлов**  
Чтобы открыть файл, программа должна вызвать функцию open, передав ей имя внешнего файла и режим работы. Обычно в качестве режима используется строка 'r', когда файл открывается для чтения (по умолчанию), 'w' – когда файл открывается для записи или 'a' – когда файл открывается на запись в конец.

 - Добавление символа b в строку режима означает работу с двоичными данными (в версии 3.0 отключается интерпретация символов конца строки и кодирование символов Юникода).
 - Добавление символа + означает, что файл открывается для чтения и для записи

Оба аргумента функции open должны быть строками. Кроме того, функция может принимать третий необязательный аргумент, управляющий буферизацией выводимых данных, – значение ноль означает, что выходная информация не будет буферизироваться (то есть она будет записываться во внешний файл сразу же, в момент вызова метода записи).

**Использование файлов**:
 - Для чтения строк лучше использовать итераторы файлов(самый лучший, пожалуй, способ чтения строк из файла на сегодняшний день состоит в том, вообще не использовать операцию чтения из файла, файлы имеют итератор, который автоматически читает информацию из файла строку за строкой в контексте цикла for, в генераторах списков и в других итерационных контекстах.)  
 - Содержимое файлов находится в строках, а не в объектах  
 - Вызов метода close является необязательным  
 - Файлы обеспечивают буферизацию ввода-вывода и позволяют производить позиционирование в файле(По умолчанию вывод в файлы  всегда выполняется с помощью промежуточных буферов, то есть в момент записи текста в файл он не попадает сразу же на диск  – буферы выталкиваются на диск только в момент закрытия файла или при вызове метода flush. Вы можете отключить механизм буферизации с помощью дополнительных параметров функции open, но это может привести к снижению производительности операций ввода-вывода. Файлы в языке Python поддерживают также возможность позиционирования – метод seek позволяет сценариям управлять позицией чтения и записи.  

??? **Текстовые и двоичные файлы в Python 3.0**

### Ссылки и копии  
Варианты создания копий объектов:  
 - выражение извлечения среза с пустыми пределами (L[:]) создает копию последовательности.
 - метод словарей и множеств copy создает копию словаря (D.copy()).
 - некоторые встроенные функции, такие как list, создают копию списка (list(L)).
 - модуль copy, входящий в состав стандартной библиотеки, создает полные копии объектов  

Например, предположим, что у нас имеются список и словарь, и для нас нежелательно изменение их значений посредством других переменных:  

                                    >>> L = [1,2,3]
                                    >>> D = {'a':1, 'b':2}

Чтобы предотвратить такую возможность, достаточно связать с другими переменными копии объектов вместо того, чтобы связать с ними сами объекты:  

                                    >>> A = L[:] # Вместо A = L (или list(L))
                                    >>> B = D.copy() # Вместо B = D (то же относится и к множествам)

В этом случае изменения, произведенные с помощью других переменных, повлияют на копии, а не на оригиналы  

Одно замечание по поводу копий: выражение извлечения среза с пустыми значениями пределов и метод словаря copy создают поверхностные копии – то есть они не копируют вложенные структуры данных, даже если таковые присутствуют. Если необходима полная копия структуры произвольной глубины вложенности, следует использовать стандартный модуль copy: добавьте инструкцию import copy и вставьте выражение X = copy.deepcopy(Y), которое создаст полную копию объекта Y со сколь угодно большой глубиной вложенности. Эта функция выполняет рекурсивный обход объектов и копирует все составные части.

### Сравнивание, равенство и истина  
существует два способа проверки на равенство:
 - Оператор == проверяет равенство значений. Интерпретатор выполняет проверку на равенство, рекурсивно сравнивая все    вложенные объекты.
 - Оператор is проверяет идентичность объектов. Интерпретатор проверяет, являются ли сравниваемые объекты одним и тем же объектом (то есть расположены ли они по одному и тому же адресу в памяти).

Однако обратите внимание, что происходит при сравнивании двух коротких строк:

                                    >>> S1 = 'spam'
                                    >>> S2 = 'spam'
                                    >>> S1 == S2, S1 is S2
                                    (True, True)

Здесь у нас так же имеется два различных объекта с одинаковыми значениями: оператор == должен вернуть истину, а оператор is – ложь. Но так как интерпретатор с целью оптимизации кэширует и повторно использует короткие строки, в действительности в обе переменные, S1 и S2, записывается ссылка на одну ту же строку 'spam' в памяти, поэтому оператор is проверки идентичности возвращает истину. Чтобы получить нормальное поведение, потребуется использовать более длинные строки:

                                    >>> S1 = 'a longer string'
                                    >>> S2 = 'a longer string'
                                    >>> S1 == S2, S1 is S2
                                    (True, False)  

Операторы отношений к вложенным структурам также применяются рекурсивно:

                            >>> L1 = [1, (‘a’, 3)]  
                            >>> L2 = [1, (‘a’, 2)]  
                            >>> L1 < L2, L1 == L2, L1 > L2 # Меньше, равно, больше: кортеж результатов  
                            (False, False, True)  

В общем случае Python сравнивает типы следующим образом:
 - Числа сравниваются по величине.
 - Строки сравниваются лексикографически, символ за символом ("abc" < "ac").
 - При сравнении списков и кортежей сравниваются все компоненты слева направо.
 - Словари сравниваются как отсортированные списки (ключ, значение). Словари в Python 3.0 не поддерживают операторы отношений.
 - Попытка сравнить значения несопоставимых нечисловых типов (например, 1 < 'spam') в Python 3.0 вызывает ошибку.  

Примеры ложных значений объектов: "", [], {}, 0.0, None;

None - не означает "неопределенный", это настоящий объект, занимающий определеную область памяти, с зарезервированным
именем. Этот объект является значением, возвращаемым функциями по умолчанию. это единственный специальный тип данных в языке
Python, который играет роль пустого заполнителя.  

Например, списки не допускают присваивание значений отсутствующим элементам, когда вы выполняете присваивание некоторого значения несуществующему элементу. Чтобы можно было выполнять присваивание любому из 100 элементов списка, обычно создается список из 100 элементов, который заполняется объектами None:

                                    >>> L = [None] * 100
                                    >>> L
                                    [None, None, None, None, None, None, None, ... ]

**Тип bool**
В языке Python имеется встроенная функция bool, которая может использоваться для проверки логического значения объекта (например, для проверки истинности объекта, чтобы убедиться, что объект не является пустым или не равен нулю):

                                    >>> bool(1)
                                    True
                                    >>> bool(‘spam’)
                                    True
                                    >>> bool({})
                                    False

**Иерархия типов данных в Python**  
Фактически даже сами типы в языке Python являются разновидностью объектов: объекты типов являются объектами типа type. Вызов встроенной функции type(X) возвращает объект типа объекта X.

в версии Python 2.2 у каждого базового типа появилось новое встроенное имя, добавленное для обеспечения поддержки настройки типов через объектно-ориентированный механизм наследования классов: dict, list, str, tuple, int, float, complex, bytes, type, set и другие.

**функция isinstance**

В составе языка имеются десятки других типов объектов - объекты регулярных выражений, компоненты графического интерфейса, сетевые сокеты и так далее. Главное отличие между этими и встроенными типами состоит в том, что для встроенных типов языком предоставляется специальный синтаксис создания объектов этих типов (например, 4 – для целого числа, [1,2] – для списка, функция open – для файла, а def и lambda – для функций). Другие типы обычно доступны в модулях стандартной библиотеки,
которые необходимо импортировать перед использованием.

Операция присваивания создает ссылку а не копию!!!

**Операция повторения добавляет один уровень вложенности**(Операция повторения последовательности добавляет последовательность саму к себе заданное число раз, но когда появляются вложенные изменяемые последовательности, эффект может не всегда получиться таким, как ожидается):  

                                      >>> L = [4, 5, 6]
                                      >>> X = L * 4 # Все равно, что [4, 5, 6] + [4, 5, 6] + ...
                                      >>> Y = [L] * 4 # [L] + [L] + ... = [L, L,...]
                                      >>> X
                                      [4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6]
                                      >>> Y
                                      [[4, 5, 6], [4, 5, 6], [4, 5, 6], [4, 5, 6]]

Так как во второй операции повторения L является вложенным списком, то в Y попадают ссылки на оригинальный список, связанный с именем L, вследствие чего начинают проявляться побочные эффекты:

                                      >>> L[1] = 0 # Воздействует на Y, но не на X
                                      >>> X
                                      [4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6]
                                      >>> Y
                                      [[4, 0, 6], [4, 0, 6], [4, 0, 6], [4, 0, 6]]

Операции повторения, конкатенации и извлечения среза создают только поверхностные копии объектов.

!!! Циклический объект. циклическая структура данных  
Всякий раз, когда интерпретатор Python обнаруживает циклическую ссылку, он выводит [...], чтобы не попасть в бесконечный цикл:

                                      >>> L = [‘grail’] # Добавление ссылки на самого себя
                                      >>> L.append(L) # Создает циклический объект: [...]
                                      >>> L
                                      [‘grail’, [...]]
