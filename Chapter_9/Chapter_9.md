**Свойства кортежей:**  
 - упорядоченные коллекции объектов произвольных типов    
 - Обеспечивают доступ к элементам по смещению  
 - Относятся к категории неизменяемых последовательностей  
 
Поскольку круглые скобки могут также окружать выражения, необходимо что-то предпринять, чтобы дать интерпретатору понять, что единственный объект в круглых скобках – это кортеж, а не простое выражение. Если необходимо получить кортеж с единственным элементом, нужно просто добавить запятую после этого элемента, перед закрывающей круглой скобкой, иначе это будет число:

                                        >>> T = (3,)
                                        >>> X = (3)
                                        
                                        >>> type(T)
                                        <class 'tuple'>

                                        >>> type(X)
                                        <class 'int'>

**list и tuple** – это встроенные функции, которые используются для преобразования в список и затем обратно в кортеж. В действительности обе функции создают новые объекты, но благодаря им создается эффект преобразования.  

                                        >>> T = ('cc', 'aa', 'dd', 'bb')  
                                        >>> tmp = list(T)  # создать список из элементов кортежа
                                        >>> t1 = tuple(tmp)
                                        >>> t1  
                                        ('cc', 'aa', 'dd', 'bb')  

**следует заметить, что правило неизменяемости применяется только к самому кортежу, но не к объектам, которые он содержит.**  

существуют ситуации, в которых кортежи можно использовать, а списки – нет. Например, в качестве ключей словаря.  

### Файлы  
встроенная функция open создает объект файла, который обеспечивает связь с файлом, размещенным в компьютере. После вызова функции open можно выполнять операции чтения и записи во внешний файл, используя методы полученного объекта.  

объекты файлов для задач работы с файлами предоставляют одни только методы.  

 - Для чтения строк лучше использовать итераторы файлов  
 - Содержимое файлов находится в строках, а не в объектах  
 - Вызов метода close является необязательным  

По умолчанию вывод в файлы всегда выполняется с помощью промежуточных буферов, то есть в момент записи текста в файл он не попадает сразу же на диск – буферы выталкиваются на диск только в момент закрытия файла или при вызове метода flush. Вы
можете отключить механизм буферизации с помощью дополнительных параметров функции open, но это может привести к снижению производительности операций ввода-вывода. Файлы в языке Python поддерживают также возможность позиционирования – метод seek позволяет сценариям управлять позицией чтения и записи.  

### Ссылки и копии  
Варианты создания копий объектов:  
 - выражение извлечения среза с пустыми пределами (L[:]) создает копию последовательности.
 - метод словарей и множеств copy создает копию словаря (D.copy()).
 - некоторые встроенные функции, такие как list, создают копию списка (list(L)).
 - модуль copy, входящий в состав стандартной библиотеки, создает полные копии объектов  

Например, предположим, что у нас имеются список и словарь, и для нас нежелательно изменение их значений посредством других переменных:  

                                    >>> L = [1,2,3]
                                    >>> D = {'a':1, 'b':2}

Чтобы предотвратить такую возможность, достаточно связать с другими переменными копии объектов вместо того, чтобы связать с ними сами объекты:  

                                    >>> A = L[:] # Вместо A = L (или list(L))
                                    >>> B = D.copy() # Вместо B = D (то же относится и к множествам)

В этом случае изменения, произведенные с помощью других переменных, повлияют на копии, а не на оригиналы  


Одно замечание по поводу копий: выражение извлечения среза с пустыми значениями пределов и метод словаря copy создают поверхностные копии – то есть они не копируют вложенные структуры данных, даже если таковые присутствуют. Если необходима полная копия структуры произвольной глубины вложенности, следует использовать стандартный модуль copy: добавьте инструкцию import copy и вставьте выражение X = copy.deepcopy(Y), которое создаст полную копию объекта Y со сколь угодно большой глубиной вложенности.

### Сравнивание, равенство и истина  
существует два способа проверки на равенство:
 - Оператор == проверяет равенство значений. Интерпретатор выполняет проверку на равенство, рекурсивно сравнивая все    вложенные объекты.
 - Оператор is проверяет идентичность объектов. Интерпретатор проверяет, являются ли сравниваемые объекты одним и тем   же объектом (то есть расположены ли они по одному и тому же адресу в памяти).

Однако обратите внимание, что происходит при сравнивании двух коротких строк:

                                    >>> S1 = 'spam'
                                    >>> S2 = 'spam'
                                    >>> S1 == S2, S1 is S2
                                    (True, True)

Здесь у нас так же имеется два различных объекта с одинаковыми значениями: оператор == должен вернуть истину, а оператор is – ложь. Но так как интерпретатор с целью оптимизации кэширует и повторно использует короткие строки, в действительности в обе переменные, S1 и S2, записывается ссылка на одну ту же строку 'spam' в памяти, поэтому оператор is проверки идентичности возвращает истину. Чтобы получить нормальное поведение, потребуется использовать более длинные строки:

                                    >>> S1 = 'a longer string'
                                    >>> S2 = 'a longer string'
                                    >>> S1 == S2, S1 is S2
                                    (True, False)  

Попытка сравнить значения несопоставимых нечисловых типов (например, 1 < 'spam') вызывает ошибку.  

Примеры ложных значений объектов: "", [], {}, 0.0, None;

None - не означает "неопределенный", это настоящий объект, занимающий определеную область памяти, с зарезервированным
именем. Этот объект является значением, возвращаемым функциями по умолчанию. это единственный специальный тип данных в языке
Python, который играет роль пустого заполнителя.  

Например, списки не допускают присваивание значений отсутствующим элементам, когда вы выполняете присваивание некоторого значения несуществующему элементу. Чтобы можно было выполнять присваивание любому из 100 элементов списка, обычно создается список из 100 элементов, который заполняется объектами None:

                                    >>> L = [None] * 100
                                    >>> L
                                    [None, None, None, None, None, None, None, ... ]

Операция присваивания создает ссылку а не копию!!!  
