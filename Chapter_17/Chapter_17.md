В любом случае область видимости переменной всегда определяется местом, где ей было присвоено значение, и никакого
отношения не имеет к месту, откуда была вызвана функция.
Всякий раз, когда вызывается функция, создается новая локальная область видимости – то есть пространство имен, в котором находятся имена, определяемые внутри функции.

Если необходимо присвоить значение имени верхнего уровня в модуле, который вмещает функцию, это имя необходимо объявить внутри функции глобальным с помощью инструкции global. Если необходимо присвоить значение имени, которое находится в объемлющей инструкции def, в Python 3.0 это имя необходимо объявить внутри функции с помощью
инструкции nonlocal.

операции непосредственного изменения объектов не рассматривают имена как локальные – это свойственно только операци-
ям присваивания. Например, если имени L присвоен список, определенный на верхнем уровне в модуле, то такая инструкция, как L.append(X), внутри функции не будет классифицировать имя L как локальное, тогда как инструкция L
= X – будет. 

Инструкция global:
 - Глобальные имена – это имена, которые определены на верхнем уровне вмещающего модуля.
 - Глобальные имена должны объявляться, только если им будут присваиваться значения внутри функций.
 - Обращаться к глобальным именам внутри функций можно и без объявления их глобальными.

                                        X = 88   # Глобальная переменная X
                                        def func():
                                            global X
                                            X = 99   # Глобальная переменная X: за пределами инструкции def
                                        func()
                                        print(X)   # Выведет 99

В этом примере было добавлено объявление global, поэтому имя X внутри инструкции def теперь ссылается на переменную X за ее пределами.

                                        y, z = 1, 2   # Глобальные переменные в модуле
                                        def all_global():
                                            global x   # Объявляется глобальной для присваивания
                                            x = y + z   # Объявлять y, z не требуется: применяется правило LEGB

Здесь все три переменные x, y и z, используемые внутри функции all_global, являются глобальными. Переменные y и z глобальными считаются потому, что внутри функции им не присваиваются значения. Переменная x считается глобальной потому, что она перечислена в инструкции global, которая явно отображает ее на область видимости модуля. Без инструкции global переменная x считалась бы локальной, так как ей присваивается значение внутри функции.

изменение переменных в другом модуле всегда поддерживалось в языке Python, следует помнить, что эти изменения могут повлечь за собой трудноуловимые ошибки.

допустимо вызывать функцию, определение которой в тексте программы находится ниже функции, откуда производится вызов.

                                    >>> def f1():
                                    ... x = 88 # Передача значения x вместо вложения функций
                                    ... f2(x) # Опережающие ссылки считаются допустимыми
                                    ...
                                    >>> def f2(x):
                                    ... print(x)

Граничные случаи: Во-первых, в отличие от имен, перечисленных в инструкции global, имена в инструкции nonlocal к моменту объявления уже должны существовать в области видимости объемлющей функции, в противном случае интерпретатор возбудит исключение – нельзя создавать имена в объемлющей области видимости с помощью инструкции присваивания:

                                    >>> def tester(start):
                                            def nested(label):
                                                nonlocal state # Нелокальные переменные должны существовать!
                                                state = 0
                                                print(label, state)
                                        ... return nested
                                    
                                    SyntaxError: no binding for nonlocal 'state' found
                                    
                                    >>> def tester(start):
                                        def nested(label):
                                            global state # Глобальные переменные могут отсутствовать
                                            state = 0 # Создаст переменную в области видимости модуля
                                            print(label, state)
                                        return nested

