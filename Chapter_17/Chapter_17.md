Всякий раз, когда в программе используется некоторое имя, интерпретатор создает, изменяет или отыскивает это имя в **пространстве имен** – в области, где находятся имена. Когда мы говорим о поиске значения имени применительно к программному коду, под термином область видимости подразумевается пространство имен: то есть место в программном коде, где имени было присвоено значение, определяет область видимости этого имени для программного кода.

Поскольку имена не объявляются заранее, интерпретатор Python по местоположению операции присваивания связывает имя с конкретным пространством имен. Другими словами, место, где выполняется присваивание, определяет пространство имен, в котором будет находиться имя, а следовательно, и область его видимости.

 - Имена, определяемые внутри инструкции def, видны только программному коду внутри инструкции def. К этим именам нельзя  обратиться за пределами функции.
 - Имена, определяемые внутри инструкции def, не вступают в конфликт с именами, находящимися за пределами инструкции def, даже если и там и там присутствуют одинаковые имена.

В любом случае область видимости переменной всегда определяется местом, где ей было присвоено значение, и никакого
отношения не имеет к месту, откуда была вызвана функция.  

Значения переменным могут быть присвоены в трех разных местах, соответствующих трем разным областям видимости:
 - Если присваивание переменной выполняется внутри инструкции def, переменная является локальной для этой функции.
 - Если присваивание производится в пределах объемлющей инструкции def, переменная является нелокальной для этой функции.
 - Если присваивание производится за пределами всех инструкций def, она является глобальной для всего файла.

Мы называем это лексической областью видимости, потому что области видимости переменных целиком определяются местоположением этих переменных в исходных текстах программы, а не местом, откуда вызываются функции.

Всякий раз, когда вызывается функция, создается новая локальная область видимости – т.е. пространство имен, в котором находятся имена, определяемые внутри функции.  

По умолчанию все имена, которым присваиваются значения внутри функции, помещаются в локальную область видимости (пространство имен, ассоциированное с вызовом функции).  Если необходимо присвоить значение имени верхнего уровня в модуле, который вмещает функцию, это имя необходимо объявить внутри функции глобальным с помощью инструкции global. Если необходимо присвоить значение имени, которое находится в объемлющей инструкции def, в Python 3.0 это имя необходимо объявить внутри функции с помощью инструкции nonlocal.

программный код, который вводится в интерактивной оболочке, в действительности находится на уровне модуля __main__ – этот модуль действует точно так же, как любой другой модуль; единственное отличие состоит лишь в том, что результаты вычислений выводятся немедленно.

любые операции присваивания, выполняемые внутри функции, классифицируют имена как локальные: инструкция =, инструкция import, инструкция def, передача аргументов и так далее.

операции непосредственного изменения объектов не рассматривают имена как локальные – это свойственно только операциям присваивания. Например, если имени L присвоен список, определенный на верхнем уровне в модуле, то такая инструкция, как L.append(X), внутри функции не будет классифицировать имя L как локальное, тогда как инструкция L = X – будет. В первом случае происходит изменение объекта списка, на который указывает L, а не самого имени L, – список L будет найден в глобальной области видимости, как обычно, и Python изменит этот список, без необходимости объявления имени global (или nonlocal). Этот пример должен помочь явственнее ощутить различия между именами и объектами: операция, изменяющая объект, совсем не то, что операция присваивания объекта имени.

Когда внутри функции выполняется операция присваивания (а не обращение к имени внутри выражения), интерпретатор всегда создает или изменяет имя в локальной области видимости, если в этой функции оно не было объявлено глобальным или нелокальным.

**Встроенная область видимости**  
В действительности, встроенная область видимости – это всего лишь встроенный модуль с именем builtis, но для того, чтобы
использовать имя builtis, необходимо импортировать модуль builtis, потому что это имя само по себе не является встроенным.

Встроенная область видимости реализована как модуль стандартной библиотеки с именем builtis, но само имя не находится во встроенной области видимости, поэтому, чтобы исследовать его, необходимо импортировать модуль.

                                        >>> import builtins
                                        >>> dir(builtins)

Примерно первая половина списка – это встроенные исключения, а вторая – встроенные функции. Согласно правилу LEGB интерпретатор выполняет поиск имен в этом модуле в последнюю очередь. Все имена из этого списка вы получаете в свое распоряжение по умолчанию.  

**Инструкция global:**
 - Глобальные имена – это имена, которые определены на верхнем уровне вмещающего модуля.
 - Глобальные имена должны объявляться, только если им будут присваиваться значения внутри функций.
 - Обращаться к глобальным именам внутри функций можно и без объявления их глобальными.

                                        X = 88   # Глобальная переменная X
                                        def func():
                                            global X
                                            X = 99   # Глобальная переменная X: за пределами инструкции def
                                        func()
                                        print(X)   # Выведет 99

В этом примере было добавлено объявление global, поэтому имя X внутри инструкции def теперь ссылается на переменную X за ее пределами.

                                        y, z = 1, 2   # Глобальные переменные в модуле
                                        def all_global():
                                            global x   # Объявляется глобальной для присваивания
                                            x = y + z   # Объявлять y, z не требуется: применяется правило LEGB

Здесь все три переменные x, y и z, используемые внутри функции all_global, являются глобальными. Переменные y и z глобальными считаются потому, что внутри функции им не присваиваются значения. Переменная x считается глобальной потому, что она перечислена в инструкции global, которая явно отображает ее на область видимости модуля. Без инструкции global переменная x считалась бы локальной, так как ей присваивается значение внутри функции.

изменение переменных в другом модуле всегда поддерживалось в языке Python, следует помнить, что эти изменения могут повлечь за собой трудноуловимые ошибки.

таблицу загруженных модулей sys.modules

Интересно, что благодаря трансформации глобальных переменных в атрибуты объекта загруженного модуля существует возможность имитировать инструкцию global, импортируя вмещающий модуль и выполняя присваивание его атрибутам. Программный код в этом файле в одном случае импортирует вмещающий модуль по имени, а в другом использует таблицу загруженных модулей sys.modules 

                                    thismod.py

                                    var = 99 # Глобальная переменная == атрибут модуля
                                    def local():
                                        var = 0 # Изменяется локальная переменная

                                    def glob1():
                                        global var # Глобальное объявление (обычное)
                                        var += 1 # Изменяется глобальная переменная

                                    def glob2():
                                        var = 0 # Изменяется локальная переменная
                                        import thismod # Импорт самого себя
                                        glob.var += 1 # Изменяется глобальная переменная

                                    def glob3():
                                        var = 0 # Изменяется локальная переменная
                                        import sys # Импорт системной таблицы
                                        glob = sys.modules[‘thismod’] # Получить объект модуля
                                                                        (или использовать __name__)
                                        glob.var += 1 # Изменяется глобальная переменная

                                    def test():
                                        print(var)
                                        local(); glob1(); glob2(); glob3()
                                        print(var)

                                    >>> import thismod
                                    >>> thismod.test()
                                    99
                                    102
                                    >>> thismod.var
                                    102

**Области видимости и вложенные функции**
                                def f1():
                                    X = 88
                                    def f2():
                                        print(X) # Сохраняет значение X в объемлющей области видимости
                                        return f2 # Возвращает f2, но не вызывает ее

                                action = f1() # Создает и возвращает функцию
                                action() # Вызов этой функции: выведет 88

В этом фрагменте при вызове action фактически запускается функция, созданная во время выполнения функции f1. Функция f2 помнит переменную X в области видимости объемлющей функции f1, которая уже неактивна.

**Фабричные функции**  
            >>> def maker(N):
                    def action(X): # Создать и вернуть функцию
                        return X ** N # Функция action запоминает значение N в объемлющей
                    return action # области видимости

В действительности имя N из объемлющей локальной области видимости сохраняется как информация о состоянии, присоединенная к функции action, и мы получаем обратно значение аргумента, возведенное в квадрат. Теперь, если снова вызвать внешнюю функцию, мы получим новую вложенную функцию уже с другой информацией о состоянии, присоединенной к ней.  

**Сохранение состояния объемлющей области видимости с помощью аргументов по умолчанию**
                                    def f2(x=x):
                                        print(x)  

В измененной версии f2 запись x=x означает, что аргумент x по умолчанию будет иметь значение переменной x объемлющей области видимости. сейчас Python автоматически сохраняет любые значения в объемлющей области видимости для последующего использования во вложенных инструкциях def.

допустимо вызывать функцию, определение которой в тексте программы находится ниже функции, откуда производится вызов.

                                    >>> def f1():
                                    ... x = 88 # Передача значения x вместо вложения функций
                                    ... f2(x) # Опережающие ссылки считаются допустимыми
                                    ...
                                    >>> def f2(x):
                                    ... print(x)

**Области видимости и значения по умолчанию применительно к переменным цикла**
Существует одно известное исключение из правила: если lambda-выражение или инструкция def вложены в цикл внутри другой
функции и вложенная функция ссылается на переменную из объемлющей области видимости, которая изменяется в цикле, все функции, созданные в этом цикле, будут иметь одно и то же значение – значение, которое имела переменная на последней итерации.  

Например, ниже предпринята попытка создать список функций, каждая из которых запоминает текущее значение переменной i из объемлющей области видимости:  

                                def makeActions():
                                    acts = []
                                    for i in range(5): # Сохранить каждое значение i
                                        acts.append(lambda x: i ** x) # Все запомнят последнее значение i!
                                    return acts

                                acts = makeActions()
                                acts[0]
                                <function <lambda> at 0x012B16B0>

Такой подход не дает желаемого результата, потому что поиск переменной в объемлющей области видимости производится позднее, при вызове вложенных функций, в результате все они получат одно и то же значение (значение, которое имела переменная цикла на последней итерации). То есть каждая функция в списке будет возвращать 4 во второй степени, потому что во всех них переменная i имеет одно и то же значение:  

                                    >>> acts[0](2) # Все возвращают 4 ** 2, последнее значение i
                                    16
                                    >>> acts[2](2) # Здесь должно быть 2 ** 2
                                    16
                                    >>> acts[4](2) # Здесь должно быть 4 ** 2
                                    16

Это один из случаев, когда необходимо явно сохранять значение из объемлющей области видимости в виде аргумента со значением по умолчанию вместо использования ссылки на переменную из объемлющей области видимости. То есть, чтобы этот фрагмент заработал, необходимо передать текущее значение переменной из объемлющей области видимости в виде значения по умолчанию. Значения по умолчанию вычисляются в момент создания вложенной функции (а не когда она вызывается), поэтому каждая из них сохранит свое собственное значение i:

                                    def makeActions():
                                        acts = []
                                        for i in range(5): # Использовать значения по умолчанию
                                            acts.append(lambda x, i=i: i ** x) # Сохранить текущее значение i
                                        return acts

                                    >>> acts = makeActions()
                                    >>> acts[0](2) # 0 ** 2
                                    0
                                    >>> acts[2](2) # 2 ** 2
                                    4
                                    >>> acts[4](2) # 4 ** 2
                                    16

существуют определенные проблемы с использованием изменяемых объектов, таких как списки и словари, при использовании их в качестве значений по умолчанию для аргументов (например, def f(a=[])). Так как значения по умолчанию реализованы в виде отдельных объектов, присоединяемых к функциям, изменяемые объекты по умолчанию сохраняют свое состояние от вызова к вызову,
а не инициализируются заново при каждом вызове.

**инструкция nonlocal**  
Инструкция nonlocal позволяет вложенным функциям не только читать, но и изменять значения переменных в областях видимости объемлющих функций. Подобно инструкции global, nonlocal объявляет имена, которые будут изменяться в теле функции и которые находятся в объемлющей области видимости. Однако, в отличие от инструкции global, nonlocal применяется только
к областям видимости объемлющих функций и не затрагивает глобальную область видимости модуля.

Кроме того, в отличие от инструкции global, имена, перечисленные в инструкции nonlocal, должны фактически существовать в об-
ласти видимости, вмещающей функцию, где встречается это объявление, – они могут существовать только в объемлющей области видимости и не могут быть созданы первой инструкцией присваивания во вложенной функции.

Кроме того, что инструкция nonlocal позволяет изменять значения переменных в объемлющих функциях, она также ограничивает область поиска имен – подобно инструкции global, инструкция nonlocal вынуждает интерпретатор начинать поиск с областей видимости объемлющих функций, пропуская локальную область видимости функции. То есть, кроме всего прочего, инструкция nonlocal означает: «пропустить локальную область видимости при поиске имен».  

На практике имена, перечисленные в инструкции nonlocal, должны быть определены в объемлющих функциях к моменту, когда поток управления достигнет инструкции nonlocal; в противном случае будет возбуждено исключение.

!!!!! Использование инструкции nonlocal для изменения переменных (page 496)

Граничные случаи: Во-первых, в отличие от имен, перечисленных в инструкции global, имена в инструкции nonlocal к моменту объявления уже должны существовать в области видимости объемлющей функции, в противном случае интерпретатор возбудит исключение – нельзя создавать имена в объемлющей области видимости с помощью инструкции присваивания:

                                    >>> def tester(start):
                                            def nested(label):
                                                nonlocal state # Нелокальные переменные должны существовать!
                                                state = 0
                                                print(label, state)
                                        ... return nested
                                    
                                    SyntaxError: no binding for nonlocal 'state' found
                                    
                                    >>> def tester(start):
                                        def nested(label):
                                            global state # Глобальные переменные могут отсутствовать
                                            state = 0 # Создаст переменную в области видимости модуля
                                            print(label, state)
                                        return nested

Во-вторых, инструкция nonlocal ограничивает область поиска имен переменных только областями видимости объемлющих функций – поиск нелокальных переменных не производится за пределами инструкций def ни в глобальной области видимости объемлющего модуля, ни во встроенной области видимости, даже если переменные с такими именами там существуют:

                                    >>> spam = 99
                                    >>> def tester():
                                        ... def nested():
                                            ... nonlocal spam # Переменная должна быть внутри def, а не в модуле!
                                            ... print(‘Current=’, spam)
                                            ... spam += 1
                                        ... return nested
                                    ...
                                    SyntaxError: no binding for nonlocal ‘spam’ found
                                    
Эти ограничения станут понятны, как только вы поймете, что иначе интерпретатор не смог бы определить, в какой из объемлющих областей следует создавать совершенно новое имя. Например, где в предыдущем примере должна была бы быть создана переменная spam при выполнении инструкции присваивания – в функции tester или в объемлющем модуле? Из-за этой неоднозначности интерпретатор вынужден определять местоположение нелокальных имен в момент создания функции, а не в момент ее вызова.

**Сохранение информации в атрибутах функций**  
Атрибуты функции определяемые пользователем, присоединяются непосредственно к функции. Данный способ позволяет получать информацию о состоянии за пределами вложенной функции (при использовании инструкции nonlocal переменные, объявленные с ее помощью, доступны только внутри вложенной инструкции def):  

                                    def tester(start):
                                        def nested(label):
                                            print(label, nested.state) # nested – объемлющая область видимости
                                            nested.state += 1 # Изменит атрибут, а не значение имени nested
                                        nested.state = start # Инициализация после создания функции
                                        return nested

                                    >>> F = tester(0)
                                    >>> F(‘spam’) # F – это функция ‘nested’
                                    spam 0 # с присоединенным атрибутом state
                                    >>> F(‘ham’)
                                    ham 1
                                    >>> F.state # Атрибут state доступен за пределами функции
                                    2
                                    >>>
                                    >>> G = tester(42) # G имеет собственный атрибут state,
                                    >>> G(‘eggs’) # отличный от одноименного атрибута функции F
                                    eggs 42
                                    >>> F(‘ham’)
                                    ham 2  

Этот программный код опирается на тот факт, что имя функции nested является локальной переменной в области видимости функции tester, включающей имя nested, – на это имя можно ссылаться и внутри функции nested. Кроме того, здесь используется то обстоятельство, что изменение самого объекта не является операцией присваивания, – операция увеличения значения nested.state изменяет часть объекта, на который ссылается имя nested, а не саму переменную с именем nested. Поскольку во вложенной функции не выполняется операция присваивания, необходимость в инструкции nonlocal отпадает сама собой.