**исключение в Python 2.6 и 3.0 – это всегда экземпляр класса.**  

**Инструкция try/except/else**  
Инструкция try – это составная инструкция. Слова try, except и else должны располагаться с одним и тем же отступом.  

                                          try:
                                              <statements>
                                          except <name1>:
                                              <statements>
                                          except (name2, name3):
                                              <statements>
                                          except <name4> as <data>:
                                              <statements>
                                          except:
                                              <statements>
                                          else:
                                              <statements>  

Блок else выполняется только в случае отсутствия исключений в блоке try.  

Когда запускается инструкция try, интерпретатор помечает текущий контекст программы, чтобы вернуться к нему, если возникнет исключение. В первую очередь выполняются инструкции, расположенные под заголовком try. Что произойдет дальше, зависит от того, будет ли возбуждено исключение в блоке try:  
 - Если исключение возникнет во время выполнения инструкций в блоке try, интерпретатор вернется к инструкции try и выполнит первое предложение except, соответствующее возбужденному исключению. После выполнения блока except управление будет передано первой инструкции, находящейся за всей инструкцией try (при условии, что в блоке except не возникло другого исключения).  
 - Если в блоке try возникло исключение и не было найдено ни одного соответствия среди предложений except, исключение будет передано инструкции try, стоящей выше в программе, или на верхний уровень процесса (что вынудит интерпретатор аварийно завершить работу программы и вывести сообщение об ошибке по умолчанию).  
 - Если в процессе выполнения блока try не возникло исключение, интерпретатор выполнит инструкции в блоке else (если имеются) и затем выполнение продолжится с первой инструкции, находящейся за всей инструкцией try.  

В предложениях except находятся обработчики исключений – они перехватывают исключения, которые возникли только в инструкциях блока try. Однако инструкции в блоке try могут вызывать функции, расположенные в разных частях программы, поэтому сам источник исключения может располагаться за пределами самой инструкции try.  

С точки зрения синтаксиса, в инструкции может присутствовать несколько предложений except, но только одно предложение else.  
 - Предложения except, в которых отсутствуют имена исключений (except:), перехватывают все исключения, ранее не перечисленные в инструкции try.  
 - Предложения except, где в круглых скобках перечислены имена исключений (except (e1, e2, e3):), перехватывают любое из перечисленных исключений.  

Интерпретатор Python просматривает предложения except сверху вниз в поисках соответствия, поэтому версию предложения с круглыми скобками можно рассматривать как аналог нескольким отдельным выражениям except, по одному для каждого исключения из списка, только в этом случае тело обработчика является общим для всех указанных исключений.  

                                                  try:  
                                                      action()
                                                  except NameError:  
                                                      ...  
                                                  except IndexError  
                                                      ...  
                                                  except KeyError:  
                                                      ...  
                                                  except (AttributeError, TypeError, SyntaxError):  
                                                      ...  
                                                  else:  
                                                      ...

В этом примере, если при выполнении функции action возникает исключение, интерпретатор возвращается к инструкции try и пытается отыскать первое предложение except, в котором указано возникшее исключение. Поиск среди предложений except ведется сверху вниз, слева направо, и выполняются инструкции в первом найденном совпадении. Если совпадений не будет найдено,
исключение продолжит распространение выше этой инструкции try. Обратите внимание, что блок else выполняется только при отсутствии исключения в функции action – этот блок не выполняется при наличии исключения, которому не было найдено соответствующее предложение except.  

Если необходимо организовать перехват всех исключений, используйте пустое предложение except. Предложение except без имени исключения – это своего рода шаблонный символ, потому что оно перехватывает любые исключения, что позволяет вам создавать и универсальные, и специфичные обработчики по своему усмотрению. Однако применение пустых предложений except влечет за собой определенные проблемы проектирования. Несмотря на удобство, они могут перехватывать нежелательные системные исключения, не связанные с работой вашего программного кода, и по случайности прерывать распространение исключений, предназначенных для других обработчиков. Например, даже выход из программы в языке Python возбуждает исключение, и поэтому было бы желательно, чтобы это исключение было пропущено. Кроме того, такая конструкция будет перехватывать исключения, вызванные обычными ошибками программирования, которые вам наверняка хотелось бы обнаружить.  

В Python 3.0 была введена альтернатива, решающая одну из этих проблем, – предложение except Exception имеет практически тот же эффект, что и пустое предложение except, но оно не перехватывает исключения, имеющие отношение к завершению программы.  

**Предложение try/else**  
без этого предложения нет никакого другого способа узнать (не устанавливая и не проверяя флаги) – выполнение программы продолжилось потому, что исключение в блоке try не было возбуждено, или потому, что исключение было перехвачено и обработано.  

**Перехват встроенных исключений**  
иногда бывает необходимо перехватить ошибку и выполнить восстановительные действия после нее. Если нежелательно, чтобы программа завершалась, когда интерпретатор возбуждает исключение, достаточно просто перехватить его, обернув участок программы в инструкцию try. Это очень важная возможность для таких программ, как серверы сети, которые должны продолжать работать постоянно.  

После того, как исключение перехватывается, оно становится неактуальным, поэтому программа продолжает выполнение ниже инструкции try вместо того, чтобы завершиться. Программный код действительно обрабатывает и ликвидирует ошибку.  

Как только ошибка будет перехвачена, выполнение продолжается с того места, где ошибка была перехвачена (то есть после инструкции try), – нет никакой возможности вернуться к тому месту, где возникла ошибка.  

**Инструкция try/finally**  
Если в инструкцию try включено предложение finally, интерпретатор всегда будет выполнять этот блок инструкций при "выходе" из инструкции try независимо от того, произошло ли исключение во время выполнения инструкций в блоке try. Общая форма этой инструкции имеет следующий вид:  

                                          try:
                                              <statements>
                                          finally:
                                              <statements>  

При использовании этой инструкции интерпретатор Python в первую очередь выполняет инструкции в блоке try. Что произойдет дальше, зависит от того, возникло ли исключение в блоке try:  
 - Если во время выполнения инструкций в блоке try исключение не возникло, интерпретатор переходит к выполнению блока finally и затем продолжает выполнять программу ниже инструкции try.  
 - Если во время выполнения инструкций в блоке try возникло исключение, интерпретатор также выполнит инструкции в блоке finally, но после этого исключение продолжит свое распространение до вышестоящей инструкции try или до обработчика исключений по умолчанию – программа не будет выполняться вслед за инструкцией try. То есть инструкции в блоке finally
будут выполнены, даже если исключение будет возбуждено, но в отличие от предложения except, предложение finally не завершает распространение исключения – оно остается актуальным после выполнения блока finally.  

Форму try/finally удобно использовать, когда необходимо гарантировать выполнение некоторых действий независимо от реакции программы на исключение. С практической точки зрения, эта форма инструкции позволяет определять завершающие действия, которые должны выполняться всегда, такие как закрытие файлов или закрытие соединений с сервером.

                                            class MyError(Exception): pass  

                                            def stuff(file):  
                                                raise MyError()  

                                            file = open('data', 'w')  

                                            try:
                                                stuff(file)  
                                            finally:
                                                file.close()

                                            print('not reached')  

В этом фрагменте мы обернули вызов функции в инструкцию try с предложением finally, чтобы гарантировать, что файл будет закрыт при любых обстоятельствах, независимо от того, будет возбуждено исключение в функции или нет. При таком подходе расположенный далее программный код может быть уверен, что содержимое выходных буферов файла было вытолкнуто из памяти
на диск.  

Когда функция в этом примере возбуждает исключение, управление передается обратно инструкции try и начинает выполняться блок finally, в котором производится закрытие файла. После этого исключение продолжает свое распространение либо пока не встретит другую инструкцию try, либо пока не будет достигнут обработчик по умолчанию, который выведет стандартное сообщение об ошибке и остановит работу программы – инструкция, находящаяся ниже инструкции try, никогда не будет достигнута. Если бы функция в этом примере не возбуждала исключение, программа точно так же выполнила бы блок finally, чтобы закрыть файл, и затем продолжила бы свое выполнение ниже инструкции try.  

**Объединенная инструкция try/except/finally**

                                            try:  
                                                основное действие  
                                            except Exception1:  
                                                обработчик1  
                                            except Exception2:  
                                                обработчик2  
                                                ...  
                                            else:  
                                                блок else  
                                            finally:  
                                                блок finally

Независимо от того, что происходило раньше, блок finally будет выполнен только после выполнения основных действий и после обработки любых возникших исключений. В действительности, блок finally будет выполнен, даже если исключение возникнет в самом обработчике исключения или в блоке else.  

Как всегда, предложение finally не прекращает распространение исключения – если к моменту выполнения блока finally имеется активное исключение, оно продолжает свое распространение после выполнения блока finally и управление передается куда-то в другое место программы (другой инструкции try или обработчику по умолчанию). Если к моменту, когда блок finally будет выполнен, нет активного исключения, выполнение программы продолжится сразу же вслед за инструкцией try.  

Таким образом, блок finally выполняется всегда, когда:  
 - В блоке основного действия возникло исключение и было обработано.  
 - В блоке основного действия возникло исключение и не было обработано.  
 - В блоке основного действия не возникло исключение.  
 - В одном из обработчиков возникло новое исключение.  

**Синтаксис объединенной инструкции try**  
Инструкция try, как минимум, должна содержать либо предложение except, либо предложение finally, и составляющие ее части должны следовать в таком порядке:  

                                            try -> except -> else -> finally

где предложения else и finally являются необязательными и может присутствовать ноль или более предложений except, но в случае присутствия предложения else должно быть указано хотя бы одно предложение except. В действительности инструкция try состоит из двух частей: из предложений except с необязательным предложением else и/или предложения finally.  

редложение else может присутствовать, только если в инструкции присутствует хотя бы одно предложение except, и всегда допускается одновременно указывать предложения except и finally, независимо от присутствия предложения else. Кроме того, допускается одновременно указывать предложения finally и else, но только если в инструкции присутствует предложение except (при этом допускается указывать предложение except без имени перехватываемого исключения, чтобы перехватывать любые исключения и запускать инструкцию raise, которая описывается ниже, чтобы повторно возбудить текущее обрабатываемое исключение). Если порядок следования предложений в инструкции будет нарушен, интерпретатор возбудит исключение, свидетельствующее о синтаксической ошибке, еще до того, как программный код будет выполнен.

**Инструкция raise**  
Чтобы явно возбудить исключение, можно использовать инструкцию raise. В общем виде инструкция raise состоит из слова raise, за которым может следовать имя класса или экземпляр возбуждаемого исключения:  

                              raise <instance> # Возбуждает экземпляр класса-исключения  
                              raise <class> # Создает и возбуждает экземпляр класса-исключения  
                              raise # Повторно возбуждает самое последнее исключение  

Исключение в Python 2.6 и 3.0 – это всегда экземпляр класса. Следовательно, первая форма инструкции raise является наиболее типичной – ей непосредственно передается экземпляр класса, который создается перед вызовом инструкции raise или внутри нее. Если инструкции передается класс, интерпретатор вызовет конструктор класса без аргументов, а полученный экземпляр передаст инструкции raise – если после имени класса добавить круглые скобки, мы получим эквивалентную форму. Третья форма инструкции raise просто повторно возбуждает текущее исключение – это удобно, когда возникает необходимость передать перехваченное исключение другому обработчику.  

Следующие две формы возбуждения встроенных исключений эквивалентны – они обе возбуждают экземпляр по имени класса, но первая из них создает экземпляр неявно:  

                              raise IndexError # Класс (экземпляр создается неявно)
                              raise IndexError() # Экземпляр (создается в инструкции)

Можно создать экземпляр заранее – инструкция raise принимает ссылки на объекты любых типов, поэтому следующие два примера точно так же возбуждают исключение IndexError, как и предыдущие:  
                              
                              exc = IndexError() # Экземпляр создается заранее
                              raise exc  

При возбуждении исключения интерпретатор отправляет возбужденный экземпляр вместе с исключением. Если инструкция try включает предложение вида except name as X:, переменной X будет присвоен экземпляр, переданный инструкции raise:  

                        try:
                            ...
                        except IndexError as X: # Переменной X будет присвоен экземпляр исключения
                            ...  

Ключевое слово as является необязательным в обработчиках инструкции try (если оно опущено, интерпретатор просто не будет присваивать экземпляр переменной), но с его помощью можно получить доступ к данным экземпляра и методам класса исключения.

                                            class MyExc(Exception): pass
                                            try:  
                                                raise MyExc("spam")
                                            except MyExc as X:
                                                print(X.args)

Независимо от того, какие исключения будут использованы, они всегда идентифицируются обычными объектами и только одно исключение может быть активным в каждый конкретный момент времени. Как только исключение перехватывается предложением except, находящимся в любом месте программы, исключение деактивируется (то есть оно не будет передано другой инструкции try), если не будет повторно возбуждено при помощи инструкции raise или в результате ошибки.

собственные исключения в программе должны быть представлены объектами экземпляров классов  

Инструкция raise, в которой отсутствует имя исключения или дополнительные данные, просто повторно возбуждает текущее исключение. В таком виде она обычно используется, когда необходимо перехватить и обработать исключение, но при этом не требуется деактивировать исключение:  

                                      try:
                                          raise IndexError('spam') # Исключения сохраняют аргументы
                                      except IndexError:
                                          print('propagating')
                                          raise # Повторное возбуждение последнего исключения

                                      propagating
                                      Traceback (most recent call last):
                                      File "<stdin>", line 2, in <module>
                                      IndexError: spam

При таком использовании инструкция raise повторно возбуждает исключение, которое затем передается обработчику более высокого уровня.  

??? raise from  

**Инструкция assert**  
Инструкция вида:  

                              assert <test>, <data> # Часть <data> является необязательной  

представляет собой эквивалент следующего фрагмента:  

                                    if __debug__:
                                        if not <test>:
                                            raise AssertionError(<data>)

Другими словами, если условное выражение возвращает ложное значение, интерпретатор возбуждает исключение: элемент данных (если присутствует) играет роль аргумента конструктора исключения. Как и все исключения, исключение AssertionError приводит к завершению программы, если не будет перехвачено инструкцией try, и в этом случае элемент данных отображается как часть сообщения об ошибке.  

**Контекстные менеджеры with/as**  
В двух словах, инструкция with/as может использоваться как альтернатива известной идиомы try/finally; подобно этой инструкции она предназначена для выполнения заключительных операций независимо от того, возникло ли исключение на этапе выполнения основного действия. Однако, в отличие от инструкции try/finally, инструкция with поддерживает более богатый возможностями протокол, позволяющий определять как предварительные, так и заключительные действия для заданного блока программного кода.