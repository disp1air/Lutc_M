Чем более автономной является функция, тем проще будет ее понять, использовать и изменять.

**Рекурсивные функции**  
Имейте в виду, что рекурсия может быть прямой или косвенной, когда функция вызывает другую функцию, которая в свою очередь вызывает функцию, вызвавшую ее.  

Рекурсия может оказаться востребованной для реализации обхода структур данных с произвольной организацией.  

некоторые методы перегрузки операторов в классах, такие как __setattr__ и __getattribute__, при неправильном использовании могут приводить к рекурсии. Рекурсия – это мощный инструмент, но ее лучше использовать только тогда, когда без нее невозможно обойтись!

**Атрибуты и аннотации**  
Можно получить базовый доступ к атрибутам функции:  

                                        def func(a):
                                            b = ‘spam’
                                            return b * a

                                        func.__name__
                                        'func'

                                        dir(func)
                                        [‘__annotations__’, ‘__call__’, ‘__class__’, ‘__closure__’, ‘__code__’,
                                        ...остальные имена опущены...
                                        ‘__repr__’, ‘__setattr__’, ‘__sizeof__’, ‘__str__’, ‘__subclasshook__’]

Механизмы интроспекции позволяют нам также исследовать детали реализации – каждая функция, например, имеет присоединенный к ней объект с программным кодом, из которого можно получить такие сведения, как список локальных переменных и аргументов:

                                        func.__code__
                                        <code object func at 0x0257C9B0, file “<stdin>”, line 1>

                                        dir(func.__code__)
                                        [‘__class__’, ‘__delattr__’, ‘__doc__’, ‘__eq__’, ‘__format__’, ‘__ge__’,
                                        ...остальные имена опущены...
                                        ‘co_argcount’, ‘co_cellvars’, ‘co_code’, ‘co_consts’, ‘co_filename’,
                                        ‘co_firstlineno’, ‘co_flags’, ‘co_freevars’, ‘co_kwonlyargcount’, ‘co_lnotab’,
                                        ‘co_name’, ‘co_names’, ‘co_nlocals’, ‘co_stacksize’, ‘co_varnames’]

                                        func.__code__.co_varnames
                                        (‘a’, ‘b’)

                                        func.__code__.co_argcount
                                        1

**Атрибуты функций**  

к функциям можно присоединять и свои атрибуты:

                                        >>> func.count = 0
                                        >>> func.count += 1
                                        >>> func.count
                                        1
                                        >>> func.handles = 'Button-Press'
                                        >>> func.handles
                                        'Button-Press'

                              dir(func)
                              ['__annotations__', '__call__', '__class__', '__closure__', '__code__',
                              ...остальные имена опущены...
                              __str__', '__subclasshook__', 'count', 'handles']


Такие атрибуты можно использовать для хранения информации о состоянии непосредственно в объекте функции
и отказаться от использования других приемов, таких как применение глобальных или нелокальных переменных и классов. В отличие от нелокальных переменных, атрибуты функций доступны в любом месте программы, где доступна сама функция.
В некотором смысле атрибуты можно рассматривать, как имитацию «статических локальных переменных», имеющихся в других
языках программирования - переменных, которые являются локальными для функции, но сохраняют свои значения после выхода из функции.  

**Аннотации функций**  
В Python 3.0 имеется возможность присоединять к объектам функций краткое описание (аннотацию) – произвольные данные об аргументах функции и о возвращаемом значении. Для создания аннотаций используется специальный синтаксис, но интерпретатор не выполняет никаких операций с ними – аннотации совершенно необязательны; если они присутствуют, они просто сохраняются в атрибутах __annotations__ объектов функций и могут использоваться другими инструментами.

Неаннотированная функция:  

                                          def func(a, b, c):
                                              return a + b + c

                                          func(1, 2, 3)
                                          6

Синтаксически аннотации функций находятся в заголовках инструкций def, в виде произвольных выражений, ассоциированных с аргументами и возвращаемыми значениями. Аннотации для аргументов указываются через двоеточие, сразу после имени аргумента. Для возвращаемого значения – после символов ->, вслед за списком аргументов. В следующем примере были добавлены аннотации ко всем трем аргументам и возвращаемому значению:

                                          def func(a: ‘spam’, b: (1, 10), c: float) -> int:
                                              return a + b + c

                                          func(1, 2, 3)
                                          6

Вызов аннотированной функции ничем не отличается от вызова обычной функции, но если в объявлении функции присутствуют аннотации, интерпретатор соберет их в словарь и присоединит его к объекту функции. Имена аргументов станут ключами, аннотация возвращаемого значения будет сохранена в ключе return, а значениям ключей этого словаря будут присвоены результаты выражений в аннотациях:

                              func.__annotations__
                              {‘a’: ‘spam’, ‘c’: <class ‘float’>, ‘b’: (1, 10), ‘return’: <class ‘int’>}

Поскольку аннотация – это всего лишь объект, присоединенный к другому объекту, ее легко можно обрабатывать(например в цикле for in).  

Обратите внимание на два интересных момента. Во-первых, в аннотированных аргументах все еще можно указывать значения по умолчанию – аннотация (и символ :) находится перед значением по умолчанию (и перед символом =). В следующем примере фрагмент a: ‘spam’ = 4 означает, что аргумент a по умолчанию получает значение 4 и аннотирован строкой ‘spam’:

                              def func(a: ‘spam’ = 4, b: (1, 10) = 5, c: float = 6) -> int:
                                  return a + b + c

                              >>> func(1, 2, 3)
                              6

                              >>> func() # 4 + 5 + 6 (все аргументы получают значения по умолчанию)
                              15

                              >>> func(1, c=10) # 1 + 5 + 10 (именованные аргументы действуют как обычно)
                              16

                              >>> func.__annotations__
                              {‘a’: ‘spam’, ‘c’: <class ‘float’>, ‘b’: (1, 10), ‘return’: <class ‘int’>}

Наконец, обратите внимание, что аннотации могут указываться только в инструкциях def, – они не могут использоваться в lambda-выражениях, потому что синтаксис lambda-выражений уже ограничивает область использования функций, определяемых таким способом.  

lambda
в языке Python имеется возможность создавать объекты функций в форме выражений. Подобно инструкции def это выражение создает функцию, которая будет вызываться позднее, но в отличие от инструкции def, выражение возвращает функцию, а не связывает ее с именем. Именно поэтому lambda-выражения иногда называют анонимными функциями.