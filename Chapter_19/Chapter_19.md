Чем более автономной является функция, тем проще будет ее понять, использовать и изменять.

**Рекурсивные функции**  
Имейте в виду, что рекурсия может быть прямой или косвенной, когда функция вызывает другую функцию, которая в свою очередь вызывает функцию, вызвавшую ее.  

Рекурсия может оказаться востребованной для реализации обхода структур данных с произвольной организацией.  

некоторые методы перегрузки операторов в классах, такие как __setattr__ и __getattribute__, при неправильном использовании могут приводить к рекурсии. Рекурсия – это мощный инструмент, но ее лучше использовать только тогда, когда без нее невозможно обойтись!

**Атрибуты и аннотации**  
Можно получить базовый доступ к атрибутам функции:  

                                        def func(a):
                                            b = ‘spam’
                                            return b * a

                                        func.__name__
                                        'func'

                                        dir(func)
                                        [‘__annotations__’, ‘__call__’, ‘__class__’, ‘__closure__’, ‘__code__’,
                                        ...остальные имена опущены...
                                        ‘__repr__’, ‘__setattr__’, ‘__sizeof__’, ‘__str__’, ‘__subclasshook__’]

Механизмы интроспекции позволяют нам также исследовать детали реализации – каждая функция, например, имеет присоединенный к ней объект с программным кодом, из которого можно получить такие сведения, как список локальных переменных и аргументов:

                                        func.__code__
                                        <code object func at 0x0257C9B0, file “<stdin>”, line 1>

                                        dir(func.__code__)
                                        [‘__class__’, ‘__delattr__’, ‘__doc__’, ‘__eq__’, ‘__format__’, ‘__ge__’,
                                        ...остальные имена опущены...
                                        ‘co_argcount’, ‘co_cellvars’, ‘co_code’, ‘co_consts’, ‘co_filename’,
                                        ‘co_firstlineno’, ‘co_flags’, ‘co_freevars’, ‘co_kwonlyargcount’, ‘co_lnotab’,
                                        ‘co_name’, ‘co_names’, ‘co_nlocals’, ‘co_stacksize’, ‘co_varnames’]

                                        func.__code__.co_varnames
                                        (‘a’, ‘b’)

                                        func.__code__.co_argcount
                                        1

**Атрибуты функций**  

к функциям можно присоединять и свои атрибуты:

                                        >>> func.count = 0
                                        >>> func.count += 1
                                        >>> func.count
                                        1
                                        >>> func.handles = 'Button-Press'
                                        >>> func.handles
                                        'Button-Press'

                              dir(func)
                              ['__annotations__', '__call__', '__class__', '__closure__', '__code__',
                              ...остальные имена опущены...
                              __str__', '__subclasshook__', 'count', 'handles']


Такие атрибуты можно использовать для хранения информации о состоянии непосредственно в объекте функции
и отказаться от использования других приемов, таких как применение глобальных или нелокальных переменных и классов. В отличие от нелокальных переменных, атрибуты функций доступны в любом месте программы, где доступна сама функция.
В некотором смысле атрибуты можно рассматривать, как имитацию «статических локальных переменных», имеющихся в других
языках программирования - переменных, которые являются локальными для функции, но сохраняют свои значения после выхода из функции.  

**Аннотации функций**  
В Python 3.0 имеется возможность присоединять к объектам функций краткое описание (аннотацию) – произвольные данные об аргументах функции и о возвращаемом значении. Для создания аннотаций используется специальный синтаксис, но интерпретатор не выполняет никаких операций с ними – аннотации совершенно необязательны; если они присутствуют, они просто сохраняются в атрибутах __annotations__ объектов функций и могут использоваться другими инструментами.

Неаннотированная функция:  

                                          def func(a, b, c):
                                              return a + b + c

                                          func(1, 2, 3)
                                          6

Синтаксически аннотации функций находятся в заголовках инструкций def, в виде произвольных выражений, ассоциированных с аргументами и возвращаемыми значениями. Аннотации для аргументов указываются через двоеточие, сразу после имени аргумента. Для возвращаемого значения – после символов ->, вслед за списком аргументов. В следующем примере были добавлены аннотации ко всем трем аргументам и возвращаемому значению:

                                          def func(a: ‘spam’, b: (1, 10), c: float) -> int:
                                              return a + b + c

                                          func(1, 2, 3)
                                          6

Вызов аннотированной функции ничем не отличается от вызова обычной функции, но если в объявлении функции присутствуют аннотации, интерпретатор соберет их в словарь и присоединит его к объекту функции. Имена аргументов станут ключами, аннотация возвращаемого значения будет сохранена в ключе return, а значениям ключей этого словаря будут присвоены результаты выражений в аннотациях:

                              func.__annotations__
                              {‘a’: ‘spam’, ‘c’: <class ‘float’>, ‘b’: (1, 10), ‘return’: <class ‘int’>}

Поскольку аннотация – это всего лишь объект, присоединенный к другому объекту, ее легко можно обрабатывать(например в цикле for in).  

Обратите внимание на два интересных момента. Во-первых, в аннотированных аргументах все еще можно указывать значения по умолчанию – аннотация (и символ :) находится перед значением по умолчанию (и перед символом =). В следующем примере фрагмент a: ‘spam’ = 4 означает, что аргумент a по умолчанию получает значение 4 и аннотирован строкой ‘spam’:

                              def func(a: ‘spam’ = 4, b: (1, 10) = 5, c: float = 6) -> int:
                                  return a + b + c

                              >>> func(1, 2, 3)
                              6

                              >>> func() # 4 + 5 + 6 (все аргументы получают значения по умолчанию)
                              15

                              >>> func(1, c=10) # 1 + 5 + 10 (именованные аргументы действуют как обычно)
                              16

                              >>> func.__annotations__
                              {‘a’: ‘spam’, ‘c’: <class ‘float’>, ‘b’: (1, 10), ‘return’: <class ‘int’>}

Наконец, обратите внимание, что аннотации могут указываться только в инструкциях def, – они не могут использоваться в lambda-выражениях, потому что синтаксис lambda-выражений уже ограничивает область использования функций, определяемых таким способом.  

lambda
в языке Python имеется возможность создавать объекты функций в форме выражений. Подобно инструкции def это выражение создает функцию, которая будет вызываться позднее, но в отличие от инструкции def, выражение возвращает функцию, а не связывает ее с именем. Именно поэтому lambda-выражения иногда называют анонимными функциями.  

В общем виде lambda-выражение состоит из ключевого слова lambda, за которым следуют один или более аргументов (точно так же, как список аргументов в круглых скобках в заголовке инструкции def) и далее, вслед за двоеточием, находится выражение.  

**lambda – это выражение, а не инструкция.** По этой причине ключевое слово lambda может появляться там, где синтаксис языка Python не позволяет использовать инструкцию def, – внутри литералов или в вызовах функций, например. Кроме того, lambda-выражение возвращает значение (новую функцию), которое при желании можно присвоить переменной, в противовес инструкции def, которая всегда связывает функцию с именем в заголовке, а не возвращает ее в виде результата.  

**Тело lambda – это не блок инструкций, а единственное выражение.** Тело lambda-выражения сродни тому, что вы помещаете в инструкцию return внутри определения def, – вы просто вводите результат в виде выражения вместо его явного возврата. Вследствие этого ограничения lambda-выражения менее универсальны, чем инструкция def – в теле lambda-выражения может
быть реализована только логика, не использующая такие инструкции, как if.  

                                >>> f = lambda x, y, z: x + y + z
                                >>> f(2, 3, 4)
                                9

Здесь имени f присваивается объект функции, созданный lambda-выражением, – инструкция def работает точно так же, но присваивание выполняет автоматически.  

В lambda-выражениях точно так же можно использовать аргументы со значениями по умолчанию:

                                    >>> x = (lambda a=”fee”, b=”fie”, c=”foe”: a + b + c)
                                    >>> x(“wee”)
                                    ‘weefiefoe’  

lambda-выражения создают локальную область видимости, как и вложенные инструкции def, и автоматически получают доступ к именам в объемлющих функциях, в модуле и во встроенной области видимости.  

                                    def knights():
                                        title = ‘Sir’
                                        action = (lambda x: title + ‘ ‘ + x)
                                        return action

                                    >>> act = knights()
                                    >>> act(‘robin’)
                                    ‘Sir robin’  

                                    L = [lambda x: x**2,
                                        lambda x: x**3,
                                        lambda x: x**4]

                                    for f in L:
                                        print(f(2)) # Выведет 4, 8, 16  

lambda-выражения наиболее полезны в качестве сокращенного варианта инструкции def, когда необходимо вставить маленькие фрагменты исполняемого программного кода туда, где использование инструкций недопустимо. Инструкция def не может быть
вставлена в литерал, потому что это – инструкция, а не выражение.  

Для реализации эквивалентной таблицы переходов с применением инструкций def потребовалось бы создать именованные функции за пределами контекста их использования:  

                                    def f1(x): return x ** 2
                                    def f2(x): return x ** 3
                                    def f3(x): return x ** 4

                                    L = [f1, f2, f3]

                                    for f in L:
                                        print(f(2))

lambda должно быть единственным выражением (а не серией инструкций)  

                                    b if a else c
                                    ((a and b) or c)

Так как выражения, подобные этим, допустимо помещать внутрь lambda-выражения, они могут использоваться для реализации логики выбора внутри lambda-функций:  

                                    >>> lower = (lambda x, y: x if x < y else y)
                                    >>> lower(‘bb’, ‘aa’)
                                    ‘aa’

                                    >>> lower(‘aa’, ‘bb’)
                                    ‘aa’

**Вложенные lambda-выражения и области видимости**  
                                    def action(x):
                                        return (lambda y: x + y)

                                    act = action(99)
                                    act
                                    <function <lambda> at 0x00A16A88>

                                    act(2)
                                    101  

Эта структура lambda-выражений ниже создает функцию, которая при вызове создает другую функцию. В обоих случаях вложенное lambda-выражение имеет доступ к переменной x в объемлющем lambda-выражении. Этот фрагмент будет работать, но программный код выглядит весьма замысловато, поэтому в интересах соблюдения удобочитаемости лучше избегать использования вложенных
друг в друга lambda-выражений.

                                    action = (lambda x: (lambda y: x + y))
                                    act = action(99)
                                    act(3)
                                    102

                                    ((lambda x: (lambda y: x + y))(99))(4)
                                    103

**Отображение функций на последовательности: map**  
Функция map применяет указанную функцию к каждому элементу последовательности и возвращает список, содержащий результаты всех вызовов функции. Например:  

                                    counters = [1, 2, 3, 4]
                                    def inc(x): return x + 10
                                    map(inc, counters)
                                    [11, 12, 13, 14]  

Функция map в Python 3.0 возвращает итерируемый объект, поэтому для вывода всех результатов в интерактивной оболочке мы используем функцию list; этого не требуется в Python 2.6.

Функция map ожидает получить в первом аргументе функцию, поэтому здесь часто можно встретить lambda-выражения:  

                                    >>> list(map((lambda x: x + 3), counters))
                                    [4, 5, 6, 7]  

функция map является встроенной функцией, поэтому она доступна всегда, всегда работает одним и тем же способом и обладает некоторыми преимуществами производительности.  

                                >>> pow(3, 4) # 3 ** 4
                                81
                                >>> map(pow, [1, 2, 3], [2, 3, 4]) # 1**2, 2**3, 3**4 # 1**2, 2**3, 3**4
                                [1, 8, 81]

При передаче нескольких последовательностей функция map предполагает, что ей будет передана функция, принимающая N аргументов для N последовательностей. Здесь функция pow при каждом вызове принимает от функции map два аргумента – по одному из каждой последовательности.

**Средства функционального программирования: filter и reduce**  
Например, следующий вызов функции filter отбирает элементы последовательности больше нуля:  

                                    list(range(-5, 5))
                                    [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]  

                                    filter((lambda x: x > 0), range(-5, 5))
                                    [1, 2, 3, 4]

Элементы последовательности, для которых применяемая функция возвращает истину, добавляются в список результатов.  

Функция reduce принимает итератор, но сама возвращает не итератор, а одиночный объект.

                                    from functools import reduce
                                    reduce((lambda x, y: x + y), [1, 2, 3, 4])
                                    10

                                    reduce((lambda x, y: x * y), [1, 2, 3, 4])
                                    24

На каждом шаге функция reduce передает текущую сумму или произведение вместе со следующим элементом списка lambda-функции. По умолчанию первый элемент последовательности принимается в качестве начального значения.  

Написать свою версию функции reduce достаточно просто. Следующая функция имитирует большинство особенностей встроенной функции и помогает понять принцип ее действия:  

                                    def myreduce(function, sequence):
                                        tally = sequence[0]
                                        for next in sequence[1:]:
                                            tally = function(tally, next)
                                        return tally

                                    >>> myreduce((lambda x, y: x + y), [1, 2, 3, 4, 5])
                                    15
                                    >>> myreduce((lambda x, y: x * y), [1, 2, 3, 4, 5])
                                    120  

Кроме того, встроенная функция reduce может принимать третий необязательный аргумент, который используется в качестве начального значения и служит значением по умолчанию, когда передаваемая последовательность не содержит ни одного элемента.

строенный модуль operator, содержащий функции, соответствующие встроенным выражениям, которые могут пригодиться при использовании некоторых функциональных инструментов.