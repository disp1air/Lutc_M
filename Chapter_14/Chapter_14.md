цикл for может работать с последовательностями любого типа, включая списки, кортежи и строки, например:

                                        >>> for x in [1, 2, 3, 4]: print(x ** 2, end=' ')
                                        1 4 9 16

                                        >>> for x in (1, 2, 3, 4): print(x ** 3, end=' ')
                                        1 8 27 64

                                        >>> for x in 'spam': print(x * 2, end=' ')
                                        ss pp aa mm

Фактически цикл for способен работать с любыми итерируемыми объектами, поддерживающими возможность выполнения итераций. На самом деле это верно для всех средств выполнения итераций, которые выполняют сканирование объектов слева направо, включая циклы for, генераторы списков, оператор in проверки на вхождение, встроенную функцию map и другие.

Объект считается итерируемым, либо если он физически является последовательностью, либо если он является объектом, который воспроизводит по одному результату за раз в контексте инструментов выполнения итераций, таких как цикл for.

### Протокол итераций: итераторы файлов  
Объекты открытых файлов имеют метод с именем readline, который читает по одной строке текста из файла за одно обращение – каждый раз, вызывая метод readline, мы перемещаемся к следующей строке. По достижении конца файла возвращается пустая строка, что может служить сигналом для выхода из цикла:

                                                >>> f = open('script1.py')
                                                >>> f.readline()
                                                'import sys\n'
                                                >>> f.readline()
                                                'print(sys.path)\n'
                                                >>> f.readline()
                                                'x = 2\n'
                                                >>> f.readline()
                                                'print(2 ** 33)\n'
                                                >>> f.readline()
                                                ''

файлы имеют метод __next__ который, всякий раз, когда его вызывают, возвращает следующую строку. По достижении конца файла метод __next__ возбуждает встроенное исключение StopIteration вместо того, чтобы возвращать пустую строку.

Объекты в языке Python считаются итерируемыми, если любой такой объект доступен для сканирования с помощью цикла for или
других итерационных инструментов, потому что все инструменты выполнения итераций вызывают метод __next__ в каждой итерации и определяют момент выхода по исключению StopIteration.

Следствие всего вышесказанного: лучший способ построчного чтения текстового файла состоит не в том, чтобы прочитать
его целиком, а в том, чтобы позволить циклу for автоматически вызывать метод __next__ для перемещения к следующей строке в каждой итерации. Например, следующий фрагмент читает содержимое файла строку за строкой без явного обращения к методам файла:

                                    >>> for line in open(‘script1.py’): # Использовать итератор файла
                                        print(line.upper(), end=’’) # Вызывает метод __next__,
                                                                    # перехватывает исключение StopIteration
                                    IMPORT SYS
                                    PRINT(SYS.PATH)
                                    X = 2
                                    PRINT(2 ** 33)

Аргумент end='' в вызове функции print подавляет вывод символа \n, потому что строки, прочитанные из файла, уже содержат этот символ (если этот аргумент опустить, выводимые строки будут перемежаться пустыми строками).

Способ, основанный на использовании метода readlines, по-прежнему может использоваться, но на сегодня он проигрывает из-за неэкономного использования памяти. Так как в этом случае файл загружается целиком, данный способ не позволит работать с файлами, слишком большими, чтобы поместиться в память компьютера.

**Выполнение итераций вручную: iter и next**
в Python 3.0 имеется встроенная функция next, которая автоматически вызывает метод __next__ объекта. Допустим, что у нас
имеется итерируемый объект X, тогда вызов next(X) будет равносилен вызову X.__next__(), но выглядит намного проще.

С технической точки зрения итерационный протокол имеет еще одну сторону. В самом начале цикл for получает итератор из итерируемого объекта, передавая его встроенной функции iter, которая возвращает объект, имеющий требуемый метод __next__:

                                    >>> L = [1, 2, 3]
                                    >>> I = iter(L)    # Получить объект-итератор
                                    >>> I.__next__()   # Вызвать __next__, чтобы перейти к следующему элементу
                                    1
                                    >>> I.__next__()
                                    2
                                    >>> I.__next__()
                                    3
                                    >>> I.__next__()
                                    Traceback (most recent call last):
                                    ...текст сообщения об ошибке опущен...
                                    StopIteration

При работе с файлами этот начальный этап не нужен, потому что объект файла имеет собственный итератор. То есть объекты файлов имеют собственный метод __next__, и потому для работы с файлами не требуется получать другой объект.

                                >>> f = open(‘script1.py’)
                                >>> iter(f) is f
                                True
                                >>> f.__next__()
                                ‘import sys\n’  

Списки и многие другие встроенные объекты не имеют собственных итераторов, потому что они поддерживают возможность участия сразу в нескольких итерациях. Чтобы начать итерации по таким объектам, необходимо предварительно вызвать функцию iter. Инструменты итераций в языке Python вызывают эти функции автоматически, однако мы также можем пользоваться ими при выполнении итераций вручную.  

                            >>> L = [1, 2, 3]
                            >>>
                            >>> for X in L: # Автоматический способ выполнения итераций
                                    print(X ** 2, end=’ ‘) # Получает итератор, вызывает __next__,
                                                        # обрабатывает исключение
                            1 4 9

                            >>> I = iter(L) # Ручной способ итераций: имитация цикла for
                            >>> while True:
                                    try: # Инструкция try обрабатывает исключения
                                        X = next(I) # Или I.__next__
                                    except StopIteration:
                                        break
                                    print(X ** 2, end=’ ‘)
                            1 4 9

**Другие итераторы встроенных типов**
Кроме файлов и фактических последовательностей, таких как списки, удобные итераторы также имеют и другие типы. Классический способ выполнить обход всех ключей словаря, например, состоит в том, чтобы явно запросить список ключей:

                            >>> D = {‘a’:1, ‘b’:2, ‘c’:3}
                            >>> for key in D.keys():
                                    print(key, D[key])

                            a 1
                            c 3
                            b 2

В последних версиях Python словари имеют итератор, который автоматически возвращает по одному ключу за раз в контексте итераций.

>>> I = iter(D)
>>> next(I)
‘a’
>>> next(I)
‘c’
>>> next(I)
‘b’
>>> next(I)
Traceback (most recent call last):
...текст сообщения об ошибке опущен...
StopIteration

Благодаря этому больше не требуется вызывать метод keys, чтобы выполнить обход ключей словаря, – цикл for автоматически будет использовать протокол итераций, извлекая ключи по одному в каждой итерации:

                                    >>> for key in D:
                                    ... print(key, D[key])

Кроме того, поддержка протокола итераций является причиной, по которой мы вынуждены были обертывать некоторые результаты в вызов функции list, чтобы увидеть все значения сразу. Итерируемые объекты возвращают элементы не в виде списка, а по одному элементу за раз:

>>> R = range(5)
>>> R # Диапазоны в версии 3.0 – это итерируемые объекты
range(0, 5)

>>> I = iter(R) # Используйте протокол итераций для обхода элементов
>>> next(I)
0
>>> next(I)
1
>>> list(range(5)) # Или функцию list для получения всех элементов сразу
[0, 1, 2, 3, 4]

Генераторы списков

                                    >>> L = [1, 2, 3, 4, 5]
                                    >>> L = [x + 10 for x in L]
                                    >>> L
                                    [21, 22, 23, 24, 25]
                                    
Выражения генераторов списков нельзя считать равнозначной заменой инструкции цикла for, потому что они создают новые объекты списков (что может иметь значение при наличии нескольких ссылок на первоначальный список), но это подходящая замена для большинства применений. Чтобы найти значение выражения, Python выполняет обход списка L, присваивая переменной x каждый очередной элемент, и собирает результаты, пропуская все элементы через выражение слева.  

### итератор range  
Встроенная функция range возвращает итератор, который не создает сразу весь список целых чисел в заданном диапазоне, а генерирует их по требованию. В случае, когда необходимо получить сразу весь список с результатами, обращение к ней следует обернуть в вызов функции list(range(...))  

                                    >>> R = range(10) # range возвращает итератор, а не список
                                    >>> R
                                    range(0, 10)

                                    >>> I = iter(R) # Вернет итератор для диапазона
                                    >>> next(I) # Переход к следующему результату
                                    0 # То же происходит в циклах for, генераторах списков и пр.
                                    >>> next(I)
                                    1

                                    >>> list(range(10)) # При необходимости можно принудительно
                                    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] # сгенерировать список  

объекты, возвращаемые функцией range, поддерживают только возможность итераций, операцию обращения к элементам по индексам и функцию len. Они не поддерживают никакие другие операции над последовательностями  

                                    >> len(R)
                                    10 
                                    >>> R[0]
                                    0
                                    >>> R[-1]
                                    9

??? Итераторы map, zip и filter