**Специальные режимы сопоставления аргументов**  
Python обеспечивает дополнительные возможности влиять на способ, которым объекты аргументов сопоставляются с именами аргументов в заголовке функции. По умолчанию сопоставление аргументов производится в соответствии с их позициями, слева направо, и функции должно передаваться столько аргументов, сколько имен указано в заголовке функции. Но кроме этого существует возможность явно указывать соответствия между аргументами и именами, определять значения по умолчанию и передавать дополнительные аргументы.

 - Сопоставление по позиции: значения и имена ставятся в соответствие по порядку, слева направо.
 - Сопоставление по именам: соответствие определяется по указанным именам аргументов.
 - Значения по умолчанию: указываются значения аргументов, которые могут не передаваться  
 - Переменное число аргументов: прием произвольного числа аргументов, позиционных или именованных  
 - Переменное число аргументов: передача произвольного числа аргументов, позиционных или именованных  
 - Только именованные аргументы: аргументы, которые должны передаваться только по имени  

Специальные режимы сопоставления делятся на случаи вызова функции и определения функции:
 - В инструкции вызова функции (func(value), func(name=value), func(*sequence), func(**dict)) при использовании простых значений соответствие именам аргументов определяется по позиции, но при использовании формы name=value соответствие определяется по именам аргументов – это называется передачей именованных аргументов. Использование форм *sequence и **dict в вызовах функций позволяет передавать произвольное число объектов по позиции или по именам в виде последовательностей и словарей соответственно.

правила в языке Python, которым необходимо следовать, если появится потребность использовать специальные режимы сопоставления аргументов:
 * В вызове функции аргументы должны указываться в следующем порядке: любые позиционные аргументы (значения), за которыми могут следовать любые именованные аргументы (name=value) и аргументы в форме *sequence, за которыми могут следовать аргументы в форме **dict. 
 * В заголовке функции аргументы должны указываться в следующем порядке: любые обычные аргументы (name), за которыми могут следовать аргументы со значениями по умолчанию (name=value), за которыми следуют аргументы в форме *name (или * в 3.0), если имеются, за которыми могут следовать любые имена или пары name=value аргументов, которые передаются только
по имени (в 3.0), за которыми могут следовать аргументы в форме **name.

В обоих случаях, и в вызове, и в заголовке функции, форма **arg должна следовать последней в списке. Если попытаться расставить аргументы в любом другом порядке, вы получите сообщение о синтаксической ошибке, потому что все остальные комбинации могут порождать неоднозначность. Действия, которые выполняет интерпретатор при сопоставлении аргументов перед присваиванием, грубо можно описать так:  

  1. Сопоставление неименованных аргументов по позициям.
  2. Сопоставление именованных аргументов по именам.
  3. Сопоставление дополнительных неименованных аргументов с кортежем *name.
  4. Сопоставление дополнительных именованных аргументов со словарем **name.
  5. Сопоставление значений по умолчанию с отсутствующими именованными аргументами.  

После этого интерпретатор убеждается, что каждому аргументу соответствует только одно значение, – в противном случае возбуждается исключение. По окончании сопоставления всех аргументов интерпретатор связывает имена аргументов с полученными объектами.

Если не используются какие-то специальные формы сопоставления, по умолчанию сопоставление значений и имен аргументов производится по позиции, слева направо.  

                                                def f(a, b, c):
                                                print(a, b, c)

                                                >>> f(1, 2, 3)
                                                1 2 3

Здесь значения передаются по позиции – имени a соответствует значение 1, имени b соответствует значение 2 и так далее

**Именованные аргументы**  
В языке Python существует возможность явно определить соответствия между значениями и именами аргументов при вызове функции. Именованные аргументы позволяют определять соответствие по именам, а не по позициям:

                                                >>> f(c=3, b=2, a=1)
                                                1 2 3

В этом вызове c=3, например, означает, что значение 3 передается функции в аргументе с именем c. Говоря более формальным языком, интерпретатор сопоставляет имя с в вызове функции с именем аргумента с в заголовке определения функции и затем передает значение 3 в этот аргумент. При использовании именованных аргументов порядок их следования не имеет никакого значения, потому что сопоставление производится по именам, а не по позициям. Существует даже возможность объединять передачу аргументов по позициям и по именам в одном вызове. В этом случае сначала будут сопоставлены все позиционные аргументы, слева направо, а потом будет выполнено сопоставление именованных аргументов:

                                                >>> f(1, c=3, b=2)
                                                1 2 3

**Значения по умолчанию**  
значения по умолчанию позволяют сделать отдельные аргументы функции необязательными – если значение не передается при вызове, аргумент получит значение по умолчанию, перед тем как будет запущено тело функции. Например, ниже приводится
функция, в которой один аргумент является обязательным, а два имеют значения по умолчанию:

                                                def f(a, b=2, c=3):
                                                    print a, b, c

При вызове такой функции мы обязаны передать значение для аргумента a, по позиции или по имени, а значения для аргументов b и с можно опустить.

                                                f(1)
                                                1 2 3

                                                f(1, 4)
                                                1 4 3

                                                f(1, c=6)
                                                1 2 6

Здесь значение 1 будет сопоставлено с аргументом по позиции, аргумент c получит значение 6, а аргумент b, в середине, – значение по умолчанию 2.

Не путайте синтаксические конструкции name=value в заголовке функции и в вызове функции – в вызове она означает использование режима сопоставления значения с именованным аргументом, а в заголовке определяет значение по
умолчанию для необязательного аргумента.

                                                def func(spam, eggs, toast=0, ham=0): # Первые 2 являются обязательными
                                                print(spam, eggs, toast, ham)

                                                func(1, 2)
                                                (1, 2, 0, 0)

                                                func(1, ham=1, eggs=0)
                                                (1, 0, 0, 1)
                                                func(spam=1, eggs=0)
                                                (1, 0, 0, 0)

                                                func(toast=1, eggs=2, spam=3)
                                                (3, 2, 1, 0)

                                                func(1, 2, 3, 4)
                                                (1, 2, 3, 4)

Обратите внимание еще раз: когда в вызовах используются именованные аргументы, порядок их следования не имеет значения, потому что сопоставление выполняется по именам, а не по позициям.

**Сбор аргументов в коллекцию**  
В первом случае, в определении функции, выполняется сборка лишних позиционных аргументов в кортеж:

                                                def f(*args):
                                                    print(args)

При вызове этой функции интерпретатор Python соберет все позиционные аргументы в новый кортеж и присвоит этот кортеж переменной args. Это будет обычный объект кортежа, поэтому из него можно извлекать элементы по индексам, выполнять обход в цикле for и так далее:  

                                                >>> f()
                                                ()

                                                >>> f(1)
                                                (1,)

                                                >>> f(1,2,3,4)
                                                (1, 2, 3, 4)

Комбинация ** дает похожий результат, но применяется при передаче именованных аргументов – в этом случае аргументы будут собраны в новый словарь, который можно обрабатывать обычными инструментами, предназначенными для работы со словарями. В определенном смысле форма ** позволяет преобразовать аргументы, передаваемые по именам, в словари, которые можно будет
обойти с помощью метода keys, итераторов словарей и так далее:

                                                def f(**args):
                                                    print(args)

                                                >>> f()
                                                {}
                                                >>> f(a=1, b=2)
                                                {'a': 1, 'b': 2}

Наконец, в заголовках функций можно комбинировать обычные аргументы, * и ** для реализации чрезвычайно гибких сигнатур вызова.  

                                                def f(a, *pargs, **kargs):
                                                    print(a, pargs, kargs)

                                                >>> f(1, 2, 3, x=1, y=2)
                                                1 (2, 3) {'y': 2, 'x': 1}

**Извлечение аргументов из коллекции**  
В последних версиях Python форму * можно также использовать в вызовах функций. В этом случае данная форма передачи аргументов имеет противоположный смысл по сравнению с применением этой формы в определениях функций – она распаковывает, а не создает коллекцию аргументов.  

                                                def func(a, b, c, d):
                                                    print(a, b, c, d)

                                                >>> args = (1, 2)
                                                >>> args += (3, 4)
                                                >>> func(*args)
                                                1 2 3 4

Точно так же форма ** в вызовах функций распаковывает словари пар ключ/значение в отдельные аргументы, которые передаются по ключу:  

                                                >>> args = {'a': 1, 'b': 2, 'c': 3}
                                                >>> args['d'] = 4
                                                >>> func(**args)
                                                1 2 3 4

Здесь также можно очень гибко комбинировать в одном вызове обычные позиционные и именованные аргументы:  

                                                >>> func(*(1, 2), **{'d': 4, 'c': 4})
                                                1 2 4 4

                                                >>> func(1, *(2, 3), **{'d': 4})
                                                1 2 3 4

                                                >>> func(1, c=3, *(2,), **{'d': 4})
                                                1 2 3 4

                                                >>> func(1, *(2, 3), d=4)
                                                1 2 3 4

                                                >>> f(1, *(2,), c=3, **{'d':4})
                                                1 2 3 4

Не путайте синтаксические конструкции */** в заголовках функций и в их вызовах – в заголовке они означают сбор всех лишних
аргументов в коллекцию, а в вызове выполняют распаковку коллекций в отдельные аргументы.

**аргументы, которые могут передаваться только по именам**
В версии Python 3.0 были обобщены правила, определяющие порядок следования разных видов аргументов в заголовках функций, что позволяет нам определять аргументы, которые могут передаваться только в форме именованных аргументов и никогда не будут заполняться значениями позиционных аргументов. Эту особенность удобно использовать, когда необходимо, чтобы функция могла принимать произвольное количество аргументов, а также ряд дополнительных параметров настройки.  

Синтаксически аргументы, которые могут передаваться только в виде именованных аргументов, оформляются в виде обычных именованных аргументов, следующих за формой *args в списке аргументов. Все такие аргументы могут передаваться в вызовы функций только по именам.  

Например, в следующем фрагменте аргумент a может передаваться как именованный или как позиционный аргумент, в b собираются все дополнительные позиционные аргументы и аргумент c может передаваться только как именованный аргумент:  

                                                def kwonly(a, *b, c):
                                                    print(a, b, c)

                                                >>> kwonly(1, 2, c=3)
                                                1 (2,) 3

                                                >>> kwonly(a=1, c=3)
                                                1 () 3

                                                >>> kwonly(1, 2, 3)
                                                TypeError: kwonly() needs keyword-only argument c

Чтобы показать, что функция не принимает списки аргументов произвольной длины, можно использовать одиночный символ *, при этом она ожидает, что все следующие за звездочкой аргументы будут передаваться по именам. Следующей функции аргумент a можно передать как позиционный или как именованный, но аргументы b и c могут передаваться только как именованные
аргументы; при этом функция не может принимать списки аргументов произвольной длины:

                                                def kwonly(a, *, b, c):
                                                    print(a, b, c)

                                                >>> kwonly(1, c=3, b=2)
                                                1 2 3

                                                >>> kwonly(c=3, b=2, a=1)
                                                1 2 3

                                                >>> kwonly(1, 2, 3)
                                                TypeError: kwonly() takes exactly 1 positional argument (3 given)

                                                >>> kwonly(1)
                                                TypeError: kwonly() needs keyword-only argument b

Вы по-прежнему можете использовать значения по умолчанию для аргументов, которые могут передаваться только в виде именованных, несмотря на то, что в заголовке функции они располагаются после символа *. Следующей функции аргумент a можно передать как именованный или как позиционный, а аргументы b и c являются необязательными, но передаваться должны только
в виде именованных аргументов:

                                                def kwonly(a, *, b=’spam’, c=’ham’):
                                                    print(a, b, c)

                                                >>> kwonly(1)
                                                1 spam ham

                                                >>> kwonly(1, c=3)
                                                1 spam 3

                                                >>> kwonly(a=1)
                                                1 spam ham

                                                >>> kwonly(c=3, b=2, a=1)
                                                1 2 3

                                                >>> kwonly(1, 2)
                                                TypeError: kwonly() takes exactly 1 positional argument (2 given)

Аргументы со значениями по умолчанию, которые могут передаваться только по именам, в действительности являются необязательными, а те же самые аргументы без значений по умолчанию превращаются в обязательные именованные аргументы:

                                                def kwonly(a, *, b, c=’spam’):
                                                    print(a, b, c)

                                                >>> kwonly(1, b=’eggs’)
                                                1 eggs spam

                                                >>> kwonly(1, c=’eggs’)
                                                TypeError: kwonly() needs keyword-only argument b

                                                >>> kwonly(1, 2)
                                                TypeError: kwonly() takes exactly 1 positional argument (2 given)

                                                def kwonly(a, *, b=1, c, d=2):
                                                    print(a, b, c, d)

                                                >>> kwonly(3, c=4)
                                                3 1 4 2

                                                >>> kwonly(3, c=4, b=5)
                                                3 5 4 2

                                                >>> kwonly(3)
                                                TypeError: kwonly() needs keyword-only argument c

                                                >>> kwonly(1, 2, 3)
                                                TypeError: kwonly() takes exactly 1 positional argument (3 given)

**Правила, определяющие порядок следования**  
Наконец, важно отметить, что аргументы, которые могут передаваться только по именам, должны указываться после одиночного символа звездочки, но не двойного; эти аргументы не могут располагаться после формы **args представления списка именованных аргументов произвольной длины, и пара символов ** без следующего за ними имени аргумента также не может появляться в списке аргументов. В обоих случаях будет выведено сообщение о синтаксической ошибке:  

                                                >>> def kwonly(a, **pargs, b, c):
                                                SyntaxError: invalid syntax

                                                >>> def kwonly(a, **, b, c):
                                                SyntaxError: invalid syntax

Это означает, что аргументы, которые могут передаваться только по именам, в заголовке функции должны предшествовать форме **args представления списка именованных аргументов произвольной длины и следовать за формой *args представления списка позиционных аргументов произвольной длины, когда присутствуют обе формы. Всякий раз, когда именованный аргумент появляется перед формой *args, он интерпретируется как позиционный аргумент со значением по умолчанию, но не как аргумент, который может передаваться только по имени:

                                        def f(a, *b, **d, c=6):
                                            print(a, b, c, d) # Только именованные аргументы
                                        SyntaxError: invalid syntax # должны предшествовать **!

                                        def f(a, *b, c=6, **d):
                                            print(a, b, c, d) # Коллекции аргументов в заголовке

                                        f(1, 2, 3, x=4, y=5) # Используется значение по умолчанию
                                        1 (2, 3) 6 {‘y’: 5, ‘x’: 4}

                                        f(1, 2, 3, x=4, y=5, c=7) # Переопределение значения по умолчанию
                                        1 (2, 3) 7 {‘y’: 5, ‘x’: 4}

                                        f(1, 2, 3, c=7, x=4, y=5) # Среди именованных аргументов
                                        1 (2, 3) 7 {‘y’: 5, ‘x’: 4}

                                        def f(a, c=6, *b, **d):
                                            print(a, b, c, d) # c не является только именованным аргументом!

                                        f(1, 2, 3, x=4)
                                        1 (3,) 2 {‘x’: 4}

В вызовах функций используются похожие правила, определяющие порядок следования аргументов: когда функции передаются аргументы, которые могут быть только именованными, они должны располагаться перед формой **args. При этом аргументы, которые могут передаваться только по именам, могут располагаться как перед формой *args, так и после нее, а также могут включаться в словарь **args:

                                        def f(a, *b, c=6, **d):
                                            print(a, b, c, d)

                                        >>> f(1, *(2, 3), **dict(x=4, y=5))
                                        1 (2, 3) 6 {‘y’: 5, ‘x’: 4}

                                        >>> f(1, *(2, 3), **dict(x=4, y=5), c=7)
                                        SyntaxError: invalid syntax # после **args!

                                        >>> f(1, *(2, 3), c=7, **dict(x=4, y=5)) # Переопределение значений
                                        1 (2, 3) 7 {‘y’: 5, ‘x’: 4} # по умолчанию

                                        >>> f(1, c=7, *(2, 3), **dict(x=4, y=5)) # Перед * или после нее
                                        1 (2, 3) 7 {‘y’: 5, ‘x’: 4}

                                        >>> f(1, *(2, 3), **dict(x=4, y=5, c=7)) # Только именованные аргументы
                                        1 (2, 3) 7 {‘y’: 5, ‘x’: 4} # внутри **

**Функция поиска минимума!!!**

!!! кортежи неизменяемые, но если кортеж содержит список, то этот список изменить можно, получается своего рода условная неизменяемость.
