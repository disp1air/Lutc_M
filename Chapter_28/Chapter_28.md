Подобно инструкции def, инструкция class создает объект и является неявной инструкцией присваивания – когда она выполняется, создается объект класса, ссылка на который сохраняется в имени, использованном в заголовке инструкции.

                                    class NextClass:
                                        def printer(self, text):
                                            self.message = text
                                            print(self.message)

                                    >>> x = NextClass()
                                    >>> x.printer('instance call')        

Когда метод вызывается с использованием квалифицированного имени экземпляра, как в данном случае, то сначала определяется местонахождение метода printer, а затем его аргументу self автоматически присваивается объект экземпляра (x). В аргумент text записывается строка, переданная в вызов метода ('instance call').

Методы могут вызываться любым из двух способов – через экземпляр или через сам класс. Например, метод printer может быть вызван с использованием имени класса, при этом ему явно требуется передать экземпляр в аргументе self:

                                    >>> NextClass.printer(x, 'class call') # Прямой вызов метода класса
                                    class call

Вызов метода, который производится через экземпляр и через имя класса, оказывает одинаковое воздействие при условии, что при вызове через имя класса передается тот же самый экземпляр. По умолчанию, если попытаться вызвать
метод без указания экземпляра, будет выведено сообщение об ошибке:

                                    >>> NextClass.printer('bad call')
                                    TypeError: unbound method printer() must be called with NextClass instance...

Приемы организации взаимодействия классов

                                    class Super:
                                        def method(self):
                                            print('in Super.method') # Поведение по умолчанию
                                        
                                        def delegate(self):
                                            self.action()            # Ожидаемый метод

                                    class Inheritor(Super): # Наследует методы, как они есть
                                        pass

                                    class Replacer(Super): # Полностью замещает method
                                        def method(self):
                                            print('in Replacer.method')

                                    class Extender(Super): # Расширяет поведение метода method
                                        def method(self):
                                            print('starting Extender.method')
                                            Super.method(self)
                                            print('ending Extender.method')

                                    class Provider(Super): # Определяет необходимый метод
                                        def action(self):
                                            print('in Provider.action')

Когда через экземпляр класса Provider вызывается метод delegate, инициируются две независимые процедуры поиска:
1. При вызове x.delegate интерпретатор отыскивает метод delegate в классе Super, начиная поиск от экземпляра класса Provider и двигаясь вверх по дереву наследования. Экземпляр x передается методу в виде аргумента self, как обычно.
2. Внутри метода Super.delegate выражение self.action приводит к запуску нового, независимого поиска в дереве наследования, начиная от экземпляра self и дальше вверх по дереву. Поскольку аргумент self ссылается на экземпляр класса Provider, метод action будет найден в подклассе Provider.

Пространства имен модулей фактически реализованы как словари и доступны в виде встроенного атрибута \_\_dict\_\_. То же относится к объектам классов и экземпляров: обращение к квалифицированному имени атрибута фактически является операцией доступа к элементу словаря, а механизм наследования атрибута работает лишь как поиск в связанных словарях.

Так же как и в модулях, инструкции, вложенные в тело инструкции class, создают атрибуты класса. Когда интерпретатор достигает инструкции class (а не тогда, когда происходит вызов класса), он выполняет все инструкции в ее теле от начала и до конца. Все присваивания, которые производятся в ходе этого процесса, создают имена в локальной области видимости класса, которые становятся атрибутами объекта класса. Благодаря этому классы напоминают
модули и функции:
 - Подобно функциям, инструкции class являются локальными областями видимости, где располагаются имена, созданные вложенными операциями присваивания.
 - Подобно именам в модуле, имена, созданные внутри инструкции class, становятся атрибутами объекта класса.

                                    class SharedData:
                                        spam = 42 # Создает атрибут данных класса

                                    >>> x = SharedData() # Создать два экземпляра
                                    >>> y = SharedData()

                                    >>> x.spam, y.spam # наследуют и используют атрибут spam
                                    (42, 42)

В данном случае из-за того, что имя spam создается на верхнем уровне в инструкции class, оно присоединяется к классу и поэтому совместно используется всеми экземплярами. Мы можем изменять значение атрибута, выполняя присваивание через имя класса, и обращаться к нему через имена экземпляров или класса

                                    >>> SharedData.spam = 99
                                    >>> x.spam, y.spam, SharedData.spam
                                    (99, 99, 99)

Поиск в дереве наследования производится только при попытке чтения атрибута, но не при присваивании: операция присваивания атрибуту объекта всегда изменяет сам объект, а не что-то другое.  

                                    >>> x.spam = 88
                                    >>> x.spam, y.spam, SharedData.spam
                                    (88, 99, 99)


Ниже приводится более понятный пример этого поведения, где одно и то же имя создается в двух местах:

                                    class MixedNames: # Определение класса
                                        data = 'spam' # Присваивание атрибуту класса
                                        
                                        def __init__(self, value): # Присваивание имени метода
                                            self.data = value # Присваивание атрибуту экземпляра
                                        
                                        def display(self):
                                            print(self.data, MixedNames.data) # Атрибут экземпляра, атрибут класса

                                    >>> x = MixedNames(1) # Создаются два объекта экземпляров,
                                    >>> y = MixedNames(2) # каждый из которых имеет свой атрибут data

                                    >>> x.display(); y.display()
                                    1 spam
                                    2 spam

Суть этого примера состоит в том, что атрибут data находится в двух разных местах: в объектах экземпляров (создаются присваиванием атрибуту self.data в методе __init__) и в классе, от которого они наследуют имена (создается присваиванием имени data в инструкции class). Метод класса display выводит обе версии – сначала атрибут экземпляра self, а затем атрибут класса.

                                    >>> class super:
                                            def hello(self):
                                                self.data1 = 'spam'

                                    >>> class sub(super):
                                            def hola(self):
                                                self.data2 = 'eggs'

Когда мы создаем экземпляр подкласса, он начинает свое существование с пустым словарем пространства имен, но имеет ссылку на класс, стоящий выше в дереве наследования. Фактически дерево наследования доступно в виде специальных атрибутов. Экземпляры обладают атрибутом \_\_class\_\_, который ссылается на класс, а классы имеют атрибут
\_\_bases\_\_, который является кортежем, содержащим ссылки на суперклассы выше в дереве наследования.

                                    >>> x = sub()
                                    >>> x.__dict__                 # словарь пространства имен экземпляра
                                    {}

                                    >>> x.__class__                # класс экземпляра
                                    <class '__main__.sub'>

                                    >>> sub.__bases__              # суперклассы данного класса
                                    (<class '__main__.super'>,)

                                    >>> super.__bases__
                                    (<class 'object'>,)

                                    >>> X.hello()
                                    >>> X.__dict__
                                    {'data1': 'spam'}

                                    >>> X.hola()
                                    >>> X.__dict__
                                    {'data1': 'spam', 'data2': 'eggs'}
                                    >>> sub.__dict__.keys()
                                    ['__module__', '__doc__', 'hola']
                                    >>> super.__dict__.keys()
                                    ['__dict__', '__module__', '__weakref__', 'hello', '__doc__'>]

Так как атрибуты фактически являются ключами словаря, существует два способа получать и изменять их значения – по квалифицированным именам или индексированием по ключу:

                                    >>> X.data1, X.__dict__['data1']
                                    ('spam', 'spam')

                                    >>> X.data3 = 'toast'
                                    >>> X.__dict__
                                    {'data1': 'spam', 'data3': 'toast', 'data2': 'eggs'}

                                    >>> X.__dict__['data3'] = 'ham'
                                    >>> X.data3
                                    'ham'

