СПИСКИ Списки, как и строки, поддерживают операторы + и * С обеих сторон оператора + должны находиться последовательности одного и того же типа. строку можно преобразовать в список с помощью метода list(), если передать ему строку.

пример генератора списка:

                                    >>> res = [c * 4 for c in 'SPAM']
                                    >>> res
                                    ['SSSS', 'PPPP', 'AAAA', 'MMMM']


СЛОВАРИ
 - доступ к элементам по ключу, а не по индексу
 - неупорядоченные коллекции произвольных объектов
 - относятся к категории изменяемых отображений
 - переменная длина, гетерогенность, произвольное число уровней вложенности

Метод keys возвращает все ключи, имеющиеся в словаре, в виде списка. Его удобно использовать для последовательной
обработки словарей. Т.к. метод keys возвращает список, то его можно отсортировать.

Как и в случае со списками, операция присваивания по существующему ключу словаря приводит к изменению ассоциированного с ним значения. Однако в отличие от списков, словари допускают выполнение присваивания по новому ключу (который ранее отсутствовал), в результате создается новый элемент словаря.Этот прием не может применяться к спискам, потому что в этом случае интерпретатор обнаруживает выход за пределы списка и генерирует сообщение об ошибке.

обход словаря циклом for возможен в двух вариантах: с помощью метода keys, возвращающего все ключи. Кроме того
можно выполнять обход ключей словаря и без вызова метода keys в операторе цикла for.

                                        for key in D.keys()
                                        for key in D   # где D - словарь


Замечания по использованию словарей
 - Операции над последовательностями неприменимы к словарям. Словари это отображения, а не последовательности.
 - Присваивание по несуществующему индексу приводит к созданию нового элемента.
 - Ключи не обязательно должны быть строками, могут использоваться любые другие неизменяемые объекты. Например, в качестве ключей допустимо использовать целые числа, что превращает словарь в подобие списка. В качестве ключей мож-
но также использовать кортежи, что позволяет создавать составные ключи. Экземпляры классов также могут играть роль ключей при условии, что они поддерживают определенные методы, которые сообщат интерпретатору, что он имеет дело с неизменяемым объектом.

Одно замечание по поводу копий: выражение извлечения среза с пустыми значениями пределов и метод словаря copy создают поверхностные копии – то есть они не копируют вложенные структуры данных, даже если таковые присутствуют. Если необходима полная копия структуры произвольной глубины вложенности, следует использовать стандартный модуль copy: добавьте инструкцию import copy и вставьте выражение X = copy.deepcopy(Y), которое создаст полную копию объекта Y со сколь угодно большой глубиной вложенности.