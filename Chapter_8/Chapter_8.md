### списки
Списки это:  
 - Упорядоченные коллекции объектов произвольных типов  
 - Доступ к элементам по смещению  
 - Переменная длина, гетерогенность и произвольное число уровней вложенности  
 - Относятся к категории изменяемых объектов  

                                    >>> L = list('spam')
                                    >>> L
                                    ['s', 'p', 'a', 'm']

                                    >>> L2 = list(range(-4, 4))
                                    >>> L2
                                    [-4, -3, -2, -1, 0, 1, 2, 3]

Поскольку списки являются последовательностями, они, как и строки, поддерживают операторы + и * С обеих сторон оператора + должны находиться последовательности одного и того же типа. Например, нельзя выполнить операцию конкатенации для списка и строки, если предварительно не преобразовать список в строку (используя, например, функцию str или оператор форматирования %) или строку в список (с помощью встроенной функцией list)  

                                    >>> str([1, 2]) + '34'  
                                    '[1, 2]34'

                                    >>> [1, 2] + list('34')  
                                    [1, 2, '3', '4']

                                    >>> 3 in [1, 2, 3] # Проверка на вхождение
                                    True

                                    >>> for x in [1, 2, 3]:
                                    ... print(x, end=’ ‘) # Итерации
                                    1 2 3

**генераторы списков** – это способ построить новый список, применяя выражение к каждому элементу последовательности; они являются близкими родственниками инструкции цикла for.

                                    >>> res = [c * 4 for c in 'SPAM']
                                    >>> res
                                    ['SSSS', 'PPPP', 'AAAA', 'MMMM']

Функционально это выражение эквивалентно циклу for, создающему список результатов вручную, но генераторы списков не только имеют более простой синтаксис, но и выполняются быстрее:

                                    >>> res = []
                                    >>> for c in 'SPAM': # Эквивалент генератора списков
                                        res.append(c * 4)

### Индексы, срезы и матрицы  
в результате операции извлечения среза всегда возвращается новый список

Присваивание срезу замещает целый раздел списка за один прием. Поскольку это довольно сложная операция, проще будет представить ее, как последовательное выполнение двух действий:
1. Удаление. Раздел списка, определяемый слева от оператора =, удаляется.
2. Вставка. Новые элементы, содержащиеся в объекте, расположенном справа от оператора =, вставляются в список, начиная с левого края, где находился прежний удаленный срез.

В действительности это не совсем то, что происходит на самом деле, но это достаточно точно объясняет, почему число вставляемых элементов не должно соответствовать числу удаляемых элементов

                                    >>> L = ['spam', 'Spam', 'SPAM!']
                                    >>> L[1] = 'eggs'
                                    >>> L
                                    ['spam', 'eggs', 'SPAM!']

                                    >>> L[0:2] = ['eat', 'more']
                                    >>> L
                                    ['eat', 'more', 'SPAM!']

Это также объясняет, почему операция L[1:2]=[] в действительности является операцией удаления – интерпретатор удалит срез (элемент со смещением 1) и затем вставит пустой список. С другой стороны, присваивание пустого списка по индексу элемента приведет к сохранению ссылки на пустой список в этом элементе, а не к его удалению: 

                                    >>> L = ['Already', 'got', 'one']
                                    >>> L[1:] = []
                                    >>> L
                                    ['Already']

                                    >>> L[0] = []
                                    >>> L
                                    [[]]

интерпретатор замещает старую ссылку на объект в указанном смещении на новую.

метод **append** - просто добавляет единственный элемент (ссылку на объект) в конец списка. В отличие от операции конкатенации, метод append принимает единственный объект, а не список.

метод sort - выполняет переупорядочивание элементов в самом списке. По умолчанию он использует стандартные операторы сравнения языка Python (в данном случае выполняется сравнивание строк) и выполняет сортировку в порядке возрастания значений. Однако существует возможность изменить порядок сортировки с помощью именованных аргументов – специальных синтаксических конструкций вида "name = value", которые используются в вызовах функций для передачи параметров настройки по их именам.

                                    >>> L = ['abc', 'ABD', 'aBe']
                                    >>> L.sort(key=str.lower, reverse=True) # Изменяет направление сортировки
                                    >>> L
                                    ['aBe', 'ABD', 'abc']

В Python 3.0 попытки сравнивания объектов различных типов возбуждают исключение – вместо сравнивания по названиям типов. Так как метод сортировки использует операцию сравнения, это означает, что инструкция [1, 2, 'spam'].sort() будет успешно выполнена в Python 2.X но возбуждено исключение в Python 3.0 и выше.

В Python 3.0 больше не поддерживается возможность передачи методу sort произвольной функции сравнения, для реализации иного способа упорядочения. Чтобы обойти это ограничение, предлагается использовать именованный аргумент key=func, в котором предусматривать возможность трансформации значений в процессе сортировки, и применять именованный аргумент reverse=True для сортировки по убыванию. То есть фактически выполнять те же действия, которые раньше выполнялись внутри функции сравнения.

Важно заметить, что методы списка append и sort изменяют сам объект списка и не возвращают список в виде результата (точнее говоря, оба метода возвращают значение None). Если написать инструкцию вроде L=L.append(X), вы не получите измененное значение L (в действительности вы вообще потеряете ссылку на список). L = None

метод **reverse** изменяет порядок следования элементов в списке на обратный, а методы **extend** и **pop** вставляют несколько элементов в конец списка и удаляют элементы из конца списка соответственно.  

метод pop может принимать необязательное смещение элемента, который удаляется из списка и возвращается (по умолчанию это последний элемент).  

                                                >>> L1 = [1, 2, 3, 4, 5]
                                                >>> L1.pop(2)
                                                3
                                                >>> L1
                                                [1, 2, 4, 5]

Другие методы списков позволяют удалять элементы с определенными значениями (remove), вставлять элементы в определенную позицию (insert), отыскивать смещение элемента по заданному значению (index) и так далее:

                                                >>> L = [‘spam’, ‘eggs’, ‘ham’]
                                                >>> L.index(‘eggs’) # Индекс объекта
                                                1

                                                >>> L.insert(1, ‘toast’) # Вставка в требуемую позицию
                                                >>> L
                                                [‘spam’, ‘toast’, ‘eggs’, ‘ham’]

                                                >>> L.remove(‘eggs’) # Удаление элемента с определенным значением
                                                >>> L
                                                [‘spam’, ‘toast’, ‘ham’]

### Словари
 - доступ к элементам по ключу, а не по индексу. Иногда словари называют ассоциативными массивами, или хешами.
 - неупорядоченные коллекции произвольных объектов
 - относятся к категории изменяемых отображений
 - переменная длина, гетерогенность, произвольное число уровней вложенности
 - таблицы ссылок на объекты

Встроенная функция **len** может работать и со словарями – она возвращает число элементов в словаре или, что то же самое, длину списка ключей. Оператор **in** проверки вхождения позволяет проверить наличие ключа. Оператор in может использоваться для работы со строками и списками, но точно так же он может использоваться и для работы со словарями. Это возможно благодаря тому, что словари определяют итераторы, которые обеспечивают пошаговый обход списков ключей.

**Метод keys** возвращает все ключи, имеющиеся в словаре, в виде списка. Его удобно использовать для последовательной
обработки словарей. Т.к. метод keys возвращает список, то его можно отсортировать. в версии 3.0 метод keys возвращает итератор, а не список. Вызов функции list принудительно выполняет обход всех значений итератора, что позволяет вывести их все сразу.  

                                    >>> list(D.keys())

**Метод values** возвращает список значений.  

Метод items возвращает кортежи пар (key, value):  

                                    >>> D = {'spam': 2, 'ham': 1, 'eggs': 3}
                                    >>> list(D.items())
                                    [('spam', 2), ('ham', 1), ('eggs', 3)]

Как и в случае со списками, операция присваивания по существующему ключу словаря приводит к изменению ассоциированного с ним значения. Однако в отличие от списков, словари допускают выполнение присваивания по новому ключу (который ранее отсутствовал), в результате создается новый элемент словаря. Этот прием не может применяться к спискам, потому что в этом случае интерпретатор обнаруживает выход за пределы списка и генерирует сообщение об ошибке.

Попытка извлечения несуществующего элемента словаря обычно приводит к появлению ошибки, однако метод get в таких случаях
возвращает значение по умолчанию (None или указанное значение). С помощью этого метода легко можно реализовать получение значений по умолчанию и избежать появления ошибки обращения к несуществующему ключу.  

Метод update реализует своего рода операцию конкатенации для словарей. Он объединяет ключи и значения одного словаря с ключами и значениями другого, просто перезаписывая значения с одинаковыми ключами:

>>> D
{‘eggs’: 3, ‘ham’: 1, ‘spam’: 2}
>>> D2 = {‘toast’:4, ‘muffin’:5}
>>> D.update(D2)
>>> D
{‘toast’: 4, ‘muffin’: 5, ‘eggs’: 3, ‘ham’: 1, ‘spam’: 2}

Наконец, метод pop удаляет ключ из словаря и возвращает его значение, в качестве аргумента может принимать ключ.

обход словаря циклом for возможен в двух вариантах: с помощью метода keys, возвращающего все ключи. Кроме того
можно выполнять обход ключей словаря и без вызова метода keys в операторе цикла for. Для любого словаря D
цикл можно оформить как for key in D:, что равносильно полной форме записи for key in D.keys():.

                                        for key in D.keys()
                                        for key in D   # где D - словарь

Замечания по использованию словарей
 - Операции над последовательностями неприменимы к словарям. Словари это отображения, а не последовательности.
 - Присваивание по несуществующему индексу приводит к созданию нового элемента.
 - Ключи не обязательно должны быть строками, могут использоваться любые другие неизменяемые объекты. Например, в качестве ключей допустимо использовать целые числа, что превращает словарь в подобие списка. В качестве ключей можно также использовать кортежи, что позволяет создавать составные ключи. Экземпляры классов также могут играть роль ключей при условии, что они поддерживают определенные методы, которые сообщат интерпретатору, что он имеет дело с неизменяемым объектом.

**Использование словарей для имитации гибких списков!!!**
Списки не допускают возможность присваивания по индексам, находящимся за пределами списков:

>>> L = []
>>> L[99] = ‘spam’
IndexError: list assignment index out of range

Можно, конечно, с помощью операции повторения создать список достаточно большой длины (например, [0]*100), но можно создать нечто похоже, задействовав словарь. При использовании целочисленных ключей словари могут имитировать списки, которые
увеличиваются при выполнении операции присваивания по смещению:

>>> D = {}
>>> D[99] = ‘spam’
>>> D[99]
‘spam’

>>> D
{99: ‘spam’}

В такой структуре можно обращаться по смещениям, как в списке, но при этом не требуется выделять пространство для всех позиций, которые могут когда-либо потребоваться при выполнении программы.

**Как избежать ошибок обращения к несуществующему ключу**
Существует по крайней мере три способа получить значение по умолчанию вместо возбуждения исключения:
 - можно предварительно проверить наличие ключа с помощью условного оператора if
 - воспользоваться конструкцией try, чтобы перехватить и явно обработать исключение
 - или просто использовать словаря get, способный возвращать значение по умолчанию для несуществующих ключей.

**Способы создания словарей**

??? **Новые возможности словарей в Python 3.0**
??? Генераторы словарей

В версии 3.0 методы словарей keys, values и items возвращают объекты представлений, тогда как в версии 2.6 они возвращают списки. Объекты представлений – это итерируемые объекты, то есть объекты, которые вместо всего списка значений возвращают по одному значению за одно обращение. Кроме того, что они являются итерируемыми объектами, представления словарей также
сохраняют оригинальный порядок следования компонентов словаря, отражают результаты операций, которые выполняются над словарем, и поддерживают операции над множествами. С другой стороны, они не являются списками и не поддерживают такие операции, как обращение к элементам по индексам или метод sort списков, а также не отображают значения своих элементов при
выводе.  

Объекты представлений, возвращаемые методом keys, похожи на множества и поддерживают операции над множествами, такие как пересечение и объединение. Объекты представлений, возвращаемые методом values, такой особенностью не обладают, потому что они не являются уникальными, тогда как объекты представлений, возвращаемые методом items, такой особенностью обладают, если пары (key, value) являются уникальными и хешируемыми.

Подобно ключам словарей, элементы множеств неупорядочены, уникальны и относятся к разряду неизменяемых объектов.

??? Сортировка ключей словаря.

В Python 2.6 словари могут сравниваться между собой с помощью операторов <, > и других, но в Python 3.x эта возможность больше не поддерживается. Однако ее можно имитировать, сравнив отсортированные списки ключей вручную:

                        sorted(D1.items()) < sorted(D2.items()) # То же, что и D1 < D2 в версии 2.6

Тем не менее в версии 3.0 сохранилась возможность проверки словарей на равенство.

Наконец, широко используемый метод has_key словарей, выполняющий проверку наличия ключей, был ликвидирован в версии 3.0. Вместо него рекомендуется использовать оператор in проверки на вхождение или проверять результат вызова метода get на равенство значению по умолчанию (первый вариант предпочтительнее)

-------------------------------

Допустим имеется список: L = [0, 1, 2, 3]

Если попытаться получить доступ к элементу, индекс которого выходит за пределы списка,
то произойдет ошибка.

Если попытаться извлечь срез, выходящий за пределы списка(например L[-1000:100]), то в
данном случае вернется первоначальный список:

                                        >>> L[-1000:100]
                                        [0, 1, 2, 3]

Если попытаться извлечь срез в обратном порядке:

                                        >>> L[3:1]
                                        []

Имеется новый список: L = [1, 2, 3, 4, 5]
Если одному из элементов присвоить пустой список, то на месте указанного элемента и будет 
пустой список:
                                        >>> L[2] = []
                                        [1, 2, [], 4, 5]

Если же присвоить пустой список срезу, то указанный срез удалится из списка:
операция присваивания срезу сначала удаляет срез, а затем вставляет новое значение в заданную позицию.

                                        >>> L[2:4]
                                        [1, 2, 5]

Инструкция del удаляет элемент с указанным смещением. Если же попытаться удалить целый срез, то как ни
странно, произойдет именно удаление целого среза:

                                        >>> L = [1, 2, 3, 4, 5]
                                        >>> del L[2:]
                                        [1, 2]

Кортежи:
    >>> X = 'spam'
    >>> Y = 'eggs'
    >>> X, Y = Y, X    # X = 'eggs' , Y = 'spam'
