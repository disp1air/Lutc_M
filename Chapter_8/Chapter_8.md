### списки
Списки это:  
 - Упорядоченные коллекции объектов произвольных типов  
 - Доступ к элементам по смещению  
 - Переменная длина, гетерогенность и произвольное число уровней вложенности  
 - Относятся к категории изменяемых объектов  

                                    >>> L = list('spam')
                                    >>> L
                                    ['s', 'p', 'a', 'm']
                                    >>> L2 = list(range(-4, 4))
                                    >>> L2
                                    [-4, -3, -2, -1, 0, 1, 2, 3]

Списки, как и строки, поддерживают операторы + и * С обеих сторон оператора + должны находиться последовательности одного и того же типа. Например, нельзя выполнить операцию конкатенации для списка и строки, если предварительно не преобразовать список в строку (используя, например, функцию str или оператор форматирования %) или строку в список (с помощью
встроенной функцией list)  

                                    >>> str([1, 2]) + '34'  
                                    '[1, 2]34'

                                    >>> [1, 2] + list('34')  
                                    [1, 2, '3', '4']

пример генератора списка:

                                    >>> res = [c * 4 for c in 'SPAM']
                                    >>> res
                                    ['SSSS', 'PPPP', 'AAAA', 'MMMM']

### присваивание по индексам и срезам  
                                    >>> L = ['spam', 'Spam', 'SPAM!']
                                    >>> L[1] = 'eggs'
                                    >>> L
                                    ['spam', 'eggs', 'SPAM!']

                                    >>> L[0:2] = ['eat', 'more']
                                    >>> L
                                    ['eat', 'more', 'SPAM!']

интерпретатор замещает старую ссылку на объект в указанном смещении на новую.

Важно заметить, что методы списка append и sort изменяют сам объект списка и не возвращают список в виде результата (точнее говоря, оба метода возвращают значение None). Если вы написали инструкцию вроде L=L.append(X), вы не получите измененное значение L (в действительности вы вообще потеряете ссылку на список).  

СЛОВАРИ
 - доступ к элементам по ключу, а не по индексу
 - неупорядоченные коллекции произвольных объектов
 - относятся к категории изменяемых отображений
 - переменная длина, гетерогенность, произвольное число уровней вложенности

**Метод keys** возвращает все ключи, имеющиеся в словаре, в виде списка. Его удобно использовать для последовательной
обработки словарей. Т.к. метод keys возвращает список, то его можно отсортировать. в версии 3.0 метод keys возвраща-
ет итератор, а не список. Вызов функции list принудительно выполняет обход всех значений итератора, что позволяет вывести их все сразу.  

                                    >>> list(D.keys())

**Метод values** возвращает список значений.  

Как и в случае со списками, операция присваивания по существующему ключу словаря приводит к изменению ассоциированного с ним значения. Однако в отличие от списков, словари допускают выполнение присваивания по новому ключу (который ранее отсутствовал), в результате создается новый элемент словаря.Этот прием не может применяться к спискам, потому что в этом случае интерпретатор обнаруживает выход за пределы списка и генерирует сообщение об ошибке.

обход словаря циклом for возможен в двух вариантах: с помощью метода keys, возвращающего все ключи. Кроме того
можно выполнять обход ключей словаря и без вызова метода keys в операторе цикла for.

                                        for key in D.keys()
                                        for key in D   # где D - словарь

оператор проверки на вхождение in может использоваться для работы со строками и списками, но точно так же он может использоваться и для работы со словарями. Это возможно благодаря тому, что словари определяют итераторы, которые обеспечивают пошаговый обход списков ключей.  

Попытка извлечения несуществующего элемента словаря обычно приводит к появлению ошибки, однако метод get в таких случаях
возвращает значение по умолчанию (None или указанное значение). С помощью этого метода легко можно реализовать получение значений по умолчанию и избежать появления ошибки обращения к несуществующему ключу.  

Замечания по использованию словарей
 - Операции над последовательностями неприменимы к словарям. Словари это отображения, а не последовательности.
 - Присваивание по несуществующему индексу приводит к созданию нового элемента.
 - Ключи не обязательно должны быть строками, могут использоваться любые другие неизменяемые объекты. Например, в качестве ключей допустимо использовать целые числа, что превращает словарь в подобие списка. В качестве ключей мож-
но также использовать кортежи, что позволяет создавать составные ключи. Экземпляры классов также могут играть роль ключей при условии, что они поддерживают определенные методы, которые сообщат интерпретатору, что он имеет дело с неизменяемым объектом.

В версии 3.0 методы словарей keys, values и items возвращают объекты представлений, тогда как в версии 2.6 они возвращают списки. Объекты представлений – это итерируемые объекты, то есть объекты, которые вместо всего списка значений возвращают по одному значению за одно обращение. Кроме того, что они являются итерируемыми объектами, представления словарей также
сохраняют оригинальный порядок следования компонентов словаря, отражают результаты операций, которые выполняются над словарем, и поддерживают операции над множествами. С другой стороны, они не являются списками и не поддерживают такие операции, как обращение к элементам по индексам или метод sort списков, а также не отображают значения своих элементов при
выводе.  

!!! Операция повторения добавляет один уровень вложенности
!!! Циклический объект. циклическая структура данных  

Допустим имеется список: L = [0, 1, 2, 3]

Если попытаться получить доступ к элементу, индекс которого выходит за пределы списка,
то произойдет ошибка.

Если попытаться извлечь срез, выходящий за пределы списка(например L[-1000:100]), то в
данном случае вернется первоначальный список:

                                        >>> L[-1000:100]
                                        [0, 1, 2, 3]

Если попытаться извлечь срез в обратном порядке:

                                        >>> L[3:1]
                                        []

Имеется новый список: L = [1, 2, 3, 4, 5]
Если одному из элементов присвоить пустой список, то на месте указанного элемента и будет 
пустой список:
                                        >>> L[2] = []
                                        [1, 2, [], 4, 5]

Если же присвоить пустой список срезу, то указанный срез удалится из списка:
операция присваивания срезу сначала удаляет срез, а затем вставляет новое значение в заданную позицию.

                                        >>> L[2:4]
                                        [1, 2, 5]

Инструкция del удаляет элемент с указанным смещением. Если же попытаться удалить целый срез, то как ни
странно, произойдет именно удаление целого среза:

                                        >>> L = [1, 2, 3, 4, 5]
                                        >>> del L[2:]
                                        [1, 2]

Кортежи:
    >>> X = 'spam'
    >>> Y = 'eggs'
    >>> X, Y = Y, X    # X = 'eggs' , Y = 'spam'
