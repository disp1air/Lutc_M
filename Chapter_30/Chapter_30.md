Полиморфизм в языке Python основан на интерфейсах объектов, а не на типах. Вы можете попробовать выполнить перегрузку методов, изменяя списки их аргументов, как показано ниже:

                                class C:
                                    def meth(self, x):

                                    def meth(self, x, y, z):
Так как инструкция def просто присваивает объект некоторому имени в области видимости класса, сохранено будет только последнее определение метода.

С точки зрения программиста, композиция – это прием встраивания других объектов в объектконтейнер и использование их для реализации методов контейнера.

!!!??? композиция

Делегирование, под которым обычно подразумевается наличие объекта-контроллера, куда встраиваются другие объекты, получающие запросы на выполнение операций.

!!!псевдочастные атрибуты, связанные и несвязанные методы.

ссылка на экземпляр передается методу, только когда он вызывается относительно экземпляра. При вызове метода через имя класса передавать ему экземпляр требуется, только если он ожидает получить его:

                                >>> class Selfless:
                                        def __init__(self, data):
                                            self.data = data
                                        def selfless(arg1, arg2): # Простая функция в 3.0
                                            return arg1 + arg2
                                        def normal(self, arg1, arg2): # Ожидает получить экземпляр при вызове
                                            return self.data + arg1 + arg2

                                >>> X = Selfless(2)
                                >>> X.normal(3, 4) # Экземпляр передается автоматически
                                9

                                >>> Selfless.normal(X, 3, 4) # Метод ожидает получить self:
                                9 # передается вручную

                                >>> Selfless.selfless(3, 4) # Вызов без экземпляра: работает в 3.0,
                                7 # но завершается ошибкой в 2.6!
Следующие два вызова завершатся ошибкой в обеих версиях Python, 2.6 и 3.0, – в первом случае (вызов относительно экземпляра) методу автоматически будет передан экземпляр, которого он не ожидает, а во втором (вызов через обращение к имени класса) метод не получит ожидаемый экземпляр:

                                >>> X.selfless(3, 4)
                                TypeError: selfless() takes exactly 2 positional arguments (3 given)

                                >>> Selfless.normal(3, 4)
                                TypeError: normal() takes exactly 3 positional arguments (2 given)

\_\_dict\_\_ - хранит только атрибуты экземпляра
dir() -  возвращает список всех унаследованных атрибутов.

встроенная функция getattr для извлечения значений атрибутов по именам в виде строк

В Python 3.0 список содержит гораздо больше атрибутов, потому что все классы являются классами «нового стиля» и наследуют атрибуты и методы от суперкласса object.

!!! \_\_repr\_\_ и бесконечный цикл.