Целые числа могут записываться как десятичные (по основанию 10), шестнадцатеричные (по основанию 16), восьмеричные (по основанию 8) и двоичные (по основанию 2):
 - **Шестнадцатеричные литералы** начинаются с комбинации символов 0x или 0X, вслед за которыми следуют шестнадцатеричные
цифры (0-9 и A-F). Шестнадцатеричные цифры могут вводиться как в нижнем, так и в верхнем регистре:  

                  0x9ff

 - **Литералы восьмеричных** чисел начинаются с комбинации символов 0o или 0O (ноль и следующий за ним символ «o»
в верхнем или нижнем регистре), вслед за которыми следуют восьмеричные цифры (0-7):

                  0o177

 - **Двоичные литералы** впервые появились в версиях 2.6 и 3.0, они начинаются с комбинации символов 0b или 0B, вслед
за которыми следуют двоичные цифры (0 – 1)

                  0b101010

- Примечательно, что все эти литералы создают объекты целых чисел – они являются всего лишь альтернативными формами записи значений. Для преобразования целого числа в строку с представлением в любой из трех систем счисления можно использовать встроенные функции hex(I), oct(I) и bin(I), кроме того, с помощью функции int(str, base) можно преобразовать строку в целое число с учетом указанного основания системы счисления.

Вещественные числа, имеют метод **as_integer_ratio**, который удобно использовать для преобразования вещественного числа в рациональное, а также метод is_integer method, который проверяет – можно ли представить вещественное число как целое значение. Целые числа тоже обладают различными атрибутами, включая новый метод **bit_length** – он возвращает количество битов, необходимых для представления значения числа.

Операторы отношений могут объединяться в цепочки: например X < Y < Z воспроизводит тот же результат, что и конструкция X < Y and Y < Z.

Если в выражении имеется несколько операторов, имеющих одинаковый приоритет, они выполняются в направлении слева направо (исключение составляет оператор возведения в степень – эти операторы выполняются справа налево, и операторы отношений, которые объединяются в направлении слева направо)

в выражениях, где участвуют значения различных типов, интерпретатор сначала выполняет преобразование типов операндов к типу самого сложного операнда, а потом применяет математику, специфичную для этого типа.

                  >>> 40 + 3.14
                  43.14

Интерпретатор Python ранжирует сложность числовых типов следующим образом: целые числа проще, чем вещественные числа, которые проще комплексных чисел.

Существует возможность принудительного преобразования типов с помощью встроенных функций:

                  >>> int(3.1415) # Усекает дробную часть вещественного числа
                  3
                  >>> float(3) # Преобразует целое число в вещественное
                  3.0

Информация про переменные:
 - переменные создаются с помощью операции присваивания.
 - прежде чем переменная сможет учавствовать в выражениях, ей должно быть присвоено значение.
 - переменные являются ссылками на объекты и никогда не объявляются заранее.

при сравнении смешивание разнотипных операндов допускается, только если оба они принадлежат
к числовым типам:

                                2.0 > 1  # число 1 преобразуется в 1.0

Деление: классическое, с округлением вниз и истинное

X / Y  -  операция истинного деления, которая всегда сохраняет дробную часть независимо от типов операндов.

X // Y  -  деление с округлением вниз, всегда отсекает дробную часть, округляя результат до ближайшего
найменьшего целого. Но если хотя бы один из операндов является вещественным числом, результат также будет
вещественным числом.

### Округление вниз и усечение дробной части
Округление вниз это вовсе не то же самое, что усечение дробной части - это обстоятельство приобретает значение
при работе с отрицательными числами

                    >>> 5 / 2,  5 / -2
                    (2.5, -2.5)

                    >>> 5 // 2, 5 // -2   # округление вниз: 2.5 округляется до 2
                    (2, -3)               # -2.5 округляется до -3

                    >>> 5 // 2.0, 5 // -2.0
                    (2.0, -3.0)

У целых чисел есть метод **bit_length**, который возвращает кол-во битов, необходимых для представления числа в 
двоичном виде. 

                    >>> x = 99
                    >>> bin(x), x.bit_length()
                    ('0b1100011', 7)

Числа с фиксированной точностью - напоминают вещественные числа, но с фиксированным числом знаков после запятой.
Можно указать как должны обрабатываться лишние десятичные цифры - усекаться или округляться. Скорость работы с
такими числами несколько ниже, чем с обычными вещественными, но такой тип идеально подходит для величин,
имеющих фиксированную точность, например денежные суммы.

...

### множества
Неупорядоченная коллекция уникальных и неизменяемых объектов, которая поддерживает операции, соответствующие
математической теории множеств. Множества поддерживают итерации, могут изменяться в размерах и могут содержать
объекты разных типов. Множество напоминает словарь, ключи в котором не имеют значений.

Множества могут включать объекты только неизменяемых(или так называемых хэшируемых) типов. Отсюда следует, что
списки и словари не могут добавляться в множества. Т.к. множества изменяемы, следовательно они не могут
вкладываться в другие множества. Но с помощью функции frozenset можно создать неизменяемое множество, которое
невозможно изменить, и потому можно встраивать в другие множества.

                              >>> engineers = {'bob', 'sue', 'ann', 'vic'}
                              >>> managers = {'tom', 'sue'}

                              >>> 'bob' in engineers
                              True

                              >>> engineers & managers
                              {'sue'}

                              >>> engineers | managers
                              {'vic', 'sue', 'tom', 'bob', 'ann'}

                              >>> engineers – managers # Инженеры, не являющиеся менеджерами
                              {'vic', 'bob', 'ann'}

                              >>> managers – engineers # Менеджеры, не являющиеся инженерами
                              {'tom'}

                              >>> engineers > managers # Все менеджеры являются инженерами?
                              False # (надмножество)

                              >>> {'bob', 'sue'} < engineers # Оба сотрудника - инженеры? (подмножество)
                              True

### логические значения  
В языке Python имеется самостоятельный логический тип bool, с двумя предопределенными значениями True и False. Эти значения являются экземплярами класса bool, который в свою очередь является всего лишь подклассом (в объектно-ориентированном смысле) встроенного целочисленного типа int. True и False ведут себя точно так же, как и целые числа 1 и 0, за исключением того, что для их вывода на экран используется другая логика – они выводятся как слова True и False вместо цифр 1 и 0. Технически это достигается за счет переопределения в классе bool методов str и repr.

                            >>>  type(True)
                            <class 'bool'>

                            >>> isinstance(True, int)
                            True

                            >>> True == 1
                            True

                            >>> True + 4
                            5
