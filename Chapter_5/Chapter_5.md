Информация про переменные:
 - переменные создаются с помощью операции присваивания.
 - прежде чем переменная сможет учавствовать в выражениях, ей должно быть присвоено значение.
 - переменные являются ссылками на объекты и никогда не объявляются заранее.

при сравнении смешивание разнотипных операндов допускается, только если оба они принадлежат
к числовым типам:

                                2.0 > 1  # число 1 преобразуется в 1.0

Деление: классическое, с округлением вниз и истинное

X / Y  -  операция истинного деления, которая всегда сохраняет дробную часть независимо от типов операндов.

X // Y  -  деление с округлением вниз, всегда отсекает дробную часть, округляя результат до ближайшего
найменьшего целого. Но если хотя бы один из операндов является вещественным числом, результат также будет
вещественным числом.

### Округление вниз и усечение дробной части
Округление вниз это вовсе не то же самое, что усечение дробной части - это обстоятельство приобретает значение
при работе с отрицательными числами

                    >>> 5 / 2,  5 / -2
                    (2.5, -2.5)

                    >>> 5 // 2, 5 // -2   # округление вниз: 2.5 округляется до 2
                    (2, -3)               # -2.5 округляется до -3

                    >>> 5 // 2.0, 5 // -2.0
                    (2.0, -3.0)

У целых чисел есть метод **bit_length**, который возвращает кол-во битов, необходимых для представления числа в 
двоичном виде. 

                    >>> x = 99
                    >>> bin(x), x.bit_length()
                    ('0b1100011', 7)

Числа с фиксированной точностью - напоминают вещественные числа, но с фиксированным числом знаков после запятой.
Можно указать как должны обрабатываться лишние десятичные цифры - усекаться или округляться. Скорость работы с
такими числами несколько ниже, чем с обычными вещественными, но такой тип идеально подходит для величин,
имеющих фиксированную точность, например денежные суммы.

...

### множества
Неупорядоченная коллекция уникальных и неизменяемых объектов, которая поддерживает операции, соответствующие
математической теории множеств. Множества поддерживают итерации, могут изменяться в размерах и могут содержать
объекты разных типов. Множество напоминает словарь, ключи в котором не имеют значений.

Множества могут включать объекты только неизменяемых(или так называемых хэшируемых) типов. Отсюда следует, что
списки и словари не могут добавляться в множества. Т.к. множества изменяемы, следовательно они не могут
вкладываться в другие множества. Но с помощью функции frozenset можно создать неизменяемое множество, которое
невозможно изменить, и потому можно встраивать в другие множества.

                              >>> engineers = {'bob', 'sue', 'ann', 'vic'}
                              >>> managers = {'tom', 'sue'}

                              >>> 'bob' in engineers
                              True

                              >>> engineers & managers
                              {'sue'}

                              >>> engineers | managers
                              {'vic', 'sue', 'tom', 'bob', 'ann'}

                              >>> engineers – managers # Инженеры, не являющиеся менеджерами
                              {'vic', 'bob', 'ann'}

                              >>> managers – engineers # Менеджеры, не являющиеся инженерами
                              {'tom'}

                              >>> engineers > managers # Все менеджеры являются инженерами?
                              False # (надмножество)

                              >>> {'bob', 'sue'} < engineers # Оба сотрудника - инженеры? (подмножество)
                              True

### логические значения  
В языке Python имеется самостоятельный логический тип bool, с двумя предопределенными значениями True и False. Эти значения являются экземплярами класса bool, который в свою очередь является всего лишь подклассом (в объектно-ориентированном смысле) встроенного целочисленного типа int. True и False ведут себя точно так же, как и целые числа 1 и 0, за исключением того, что для их вывода на экран используется другая логика – они выводятся как слова True и False вместо цифр 1 и 0. Технически это достигается за счет переопределения в классе bool методов str и repr.

                            >>>  type(True)
                            <class 'bool'>

                            >>> isinstance(True, int)
                            True

                            >>> True == 1
                            True

                            >>> True + 4
                            5
