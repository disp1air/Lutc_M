Целые числа могут записываться как десятичные (по основанию 10), шестнадцатеричные (по основанию 16), восьмеричные (по основанию 8) и двоичные (по основанию 2), это всего лишь альтернативный синтаксис задания значений целочисленных объектов:
По умолчанию интерпретатор Python выводит числа в десятичной системе счисления (по основанию 10)(т.е. при записи литералов в любой форме результат будет приведен к десятичной системе счисления)

 - **Шестнадцатеричные литералы** начинаются с комбинации символов 0x или 0X, вслед за которыми следуют шестнадцатеричные
цифры (0-9 и A-F). Шестнадцатеричные цифры могут вводиться как в нижнем, так и в верхнем регистре:  

                            >>> 0x01, 0x10, 0xFF # Шестнадцатеричные литералы
                            (1, 16, 255)

 - **Литералы восьмеричных** чисел начинаются с комбинации символов 0o или 0O (ноль и следующий за ним символ «o»
в верхнем или нижнем регистре), вслед за которыми следуют восьмеричные цифры (0-7):

                            >>> 0o1, 0o20, 0o377 # Восьмеричные литералы
                            (1, 16, 255)

 - **Двоичные литералы** впервые появились в версиях 2.6 и 3.0, они начинаются с комбинации символов 0b или 0B, вслед
за которыми следуют двоичные цифры (0 – 1)

                            >>> 0b1, 0b10000, 0b11111111 # Двоичные литералы
                            (1, 16, 255)

- Примечательно, что все эти литералы создают объекты целых чисел – они являются всего лишь альтернативными формами записи значений. Для преобразования целого числа в строку с представлением в любой из трех систем счисления можно использовать встроенные функции hex(I), oct(I) и bin(I), кроме того, с помощью функции int(str, base) можно преобразовать строку в целое число с учетом указанного основания системы счисления.

Функция oct преобразует десятичное число в восьмеричное представление, функция hex – в шестнадцатеричное, а функция bin – в двоичное:  

                            >>> oct(64), hex(64), bin(64)
                            ('0o100', '0x40', '0b1000000')

Кроме того, существует возможность обратного преобразования – встроенная функция int преобразует строку цифр в целое число. Во втором необязательном аргументе она может принимать основание системы счисления:

                      >>> int('64'), int('100', 8), int('40', 16), int('1000000', 2)
                      (64, 64, 64, 64)

                      >>> int('0x40', 16), int('0b1000000', 2) # Допускается использовать литералы
                      (64, 64)

Наконец, целые числа могут быть преобразованы в восьмеричное и шестнадцатеричное представления с помощью строкового метода форматирования и оператора форматирования строк:

                            >>> '{0:o}, {1:x}, {2:b}'.format(64, 64, 64)
                            '100, 40, 1000000'

                            >>> '%o, %x, %X' % (64, 255, 255)
                            '100, ff, FF'

Вещественные числа, имеют метод **as_integer_ratio**, который удобно использовать для преобразования вещественного числа в рациональное, а также метод is_integer method, который проверяет – можно ли представить вещественное число как целое значение. Целые числа тоже обладают различными атрибутами, включая новый метод **bit_length** – он возвращает количество битов, необходимых для представления значения числа.

Операторы отношений могут объединяться в цепочки: например X < Y < Z воспроизводит тот же результат, что и конструкция X < Y and Y < Z.

Если в выражении имеется несколько операторов, имеющих одинаковый приоритет, они выполняются в направлении слева направо (исключение составляет оператор возведения в степень – эти операторы выполняются справа налево, и операторы отношений, которые объединяются в направлении слева направо)

в выражениях, где участвуют значения различных типов, интерпретатор сначала выполняет преобразование типов операндов к типу самого сложного операнда, а потом применяет математику, специфичную для этого типа.

                                        >>> 40 + 3.14
                                        43.14

Интерпретатор Python ранжирует сложность числовых типов следующим образом: целые числа проще, чем вещественные числа, которые проще комплексных чисел.

Существует возможность принудительного преобразования типов с помощью встроенных функций:

                                        >>> int(3.1415) # Усекает дробную часть вещественного числа
                                        3
                                        >>> float(3) # Преобразует целое число в вещественное
                                        3.0

Все эти преобразования производятся только при смешивании числовых типов (то есть целых и вещественных чисел) в выражении, включая выражения, выполняющие математические операции и операции сравнения. Вообще, Python не выполняет автоматическое преобразование других типов. Например, попытка выполнить операцию сложения строки и числа приведет к появлению ошибки, если вручную не выполнить преобразование типа одного из операндов.

**В версии 3.0 сравнивание разнотипных нечисловых значений не допускается и приводит к исключению.**

полиморфизм – этот термин означает, что выполняемая операция зависит от типов объектов-операндов, над которыми она выполняется. Например, оператор + выполняет операцию сложения, когда применяется к числам, но когда он применяется к последовательностям, таким как строки или списки, он выполняет операцию конкатенации.

**Информация про переменные**:
 - переменные создаются с помощью операции присваивания.
 - прежде чем переменная сможет учавствовать в выражениях, ей должно быть присвоено значение.
 - переменные являются ссылками на объекты и никогда не объявляются заранее.

**Форматы представления repr и str**
Обе функции преобразуют произвольные объекты в их строковое представление: **repr** (и функция автоматического вывода в интерактивной оболочке) выводит результаты в том виде, в каком они были бы указаны в программном коде. **str** (и операция print) обычно выполняет преобразование значения в более дружественное представление.

Помимо операции получения строкового представления произвольных объектов имя str так же является именем типа строковых данных и может вызываться с названием кодировки в качестве аргумента для преобразования строк байтов в строки Юникода.

при сравнении смешивание разнотипных операндов допускается, только если оба они принадлежат к числовым типам:

                                2.0 > 1  # число 1 преобразуется в 1.0

                                >>> 1 == 2 < 3 # То же, что и: 1 == 2 and 2 < 3
                                False

**Деление: классическое, с округлением вниз и истинное**

X / Y  -  операция истинного деления, которая всегда сохраняет дробную часть независимо от типов операндов.

X // Y  -  деление с округлением вниз, всегда отсекает дробную часть, округляя результат до ближайшего
найменьшего целого. Но если хотя бы один из операндов является вещественным числом, результат также будет
вещественным числом.

В версии 3.0 тип результата операции // по-прежнему зависит от типов операндов: если хотя бы один из операндов является вещественным числом, результат также будет вещественным числом; в противном случае результат будет целым числом.

### Округление вниз и усечение дробной части
Округление вниз это вовсе не то же самое, что усечение дробной части - это обстоятельство приобретает значение
при работе с отрицательными числами

                    >>> 5 / 2,  5 / -2
                    (2.5, -2.5)

                    >>> 5 // 2, 5 // -2   # округление вниз: 2.5 округляется до 2
                    (2, -3)               # -2.5 округляется до -3

                    >>> 5 // 2.0, 5 // -2.0
                    (2.0, -3.0)

**Битовые операции**
                    >>> x = 0b0001
                    >>> bin(x << 2)
                    '0b0100'

                    >>> x = 0xFF
                    >>> bin(x)  
                    '0b11111111'

                    >>> X ^ 0b10101010 # Битовая операция ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR)
                    85

У целых чисел есть метод **bit_length**, который возвращает кол-во битов, необходимых для представления числа в 
двоичном виде. 

                    >>> x = 99
                    >>> bin(x), x.bit_length()
                    ('0b1100011', 7)

**Встроенные средства для работы с числами**
Встроенные функции **pow** и **abs**, например, вычисляют степень и абсолютное значение числа соответственно. Функция sum, принимает последовательность чисел, а функции min и max могут принимать либо последовательность чисел, либо множество отдельных аргументов

                    >>> pow(2, 4), 2 ** 4 # Возведение в степень
                    (16, 16)

                    >>> abs(-42.0), sum((1, 2, 3, 4)) # Абсолютное значение, сумма
                    (42.0, 10)

                    >>> min(3, 1, 2, 4), max(3, 1, 2, 4) # Минимум, максимум
                    (1, 4)

Обратите внимание, что модули из стандартной библиотеки, такие как math, необходимо импортировать, а встроенные функции, такие как abs и round, доступны всегда, без выполнения операции импорта. Говоря другими словами, модули – это внешние компоненты, а встроенные функции постоянно располагаются в пространстве имен, которое используется интерпретатором Python
по умолчанию для поиска имен, используемых программой. В Python 3.0 это пространство имен соответствует модулю с именем builtin (__builtin__ в версии 2.6).

Модуль random предоставляет возможность получения случайных вещественных чисел в диапазоне от 0 до 1, случайных целых чисел в заданном диапазоне, случайного выбора элементов последовательности и многое другое:

                    >>> import random
                    >>> random.random()
                    0.44694718823781876

                    >>> random.randint(1, 10)
                    5

                    >>> random.choice(['Life of Brian', 'Holy Grail', 'Meaning of Life'])
                    'Life of Brian'

Числа с фиксированной точностью - напоминают вещественные числа, но с фиксированным числом знаков после запятой.
Можно указать как должны обрабатываться лишние десятичные цифры - усекаться или округляться. Скорость работы с
такими числами несколько ниже, чем с обычными вещественными, но такой тип идеально подходит для величин,
имеющих фиксированную точность, например денежные суммы.

**???** Например, результат следующего выражения должен быть равен нулю, но точность вычислений страдает из-за недостаточного числа битов в представлении вещественных чисел:

                    >>> 0.1 + 0.1 + 0.1 - 0.3
                    5.5511151231257827e-017

Однако при использовании чисел с фиксированной точностью результат получается точным:

                    >>> from decimal import Decimal
                    >>> Decimal('0.1') + Decimal('0.1') + Decimal('0.1') - Decimal('0.3')
                    Decimal('0.0')

числа с фиксированной точностью представления создаются вызовом функции конструктора Decimal из модуля decimal, ко-
торому передается строка, содержащая желаемое число знаков после запятой. Когда в выражении участвуют числа с различной точностью представления, Python автоматически выбирает наибольшую точность для представления результата:

                    >>> Decimal('0.1') + Decimal('0.10') + Decimal('0.10') - Decimal('0.30')
                    Decimal('0.00')                    

**Глобальные настройки точности**
В модуле decimal имеются дополнительные инструменты, позволяющие задавать точность представления всех таких чисел и многое другое. Например, объект контекста в этом модуле позволяет задавать точность (число знаков после запятой) и режим округления (вниз, вверх и так далее). Точность задается глобально, для всех чисел с фиксированной точностью, создаваемых в текущем потоке управления.

**Рациональные числа**
В Python 2.6 и 3.0 появился новый числовой тип – Fraction, который реализует объекты рациональных чисел. Объекты этого типа в явном виде хранят числитель и знаменатель рациональной дроби, что позволяет избежать неточности и некоторых других ограничений, присущих вещественным числам. Чтобы создать объект этого типа, необходимо импортировать модуль и вызвать конструктор класса, передав ему числитель и знаменатель:

                      >>> from fractions import Fraction
                      >>> x = Fraction(1, 3) # Числитель, знаменатель
                      >>> y = Fraction(4, 6) # Будет упрощено до 2, 3 с помощью функции gcd

                      >>> x
                      Fraction(1, 3)

Рациональные числа могут создаваться из строк с представлением вещественных чисел, как и числа с фиксированной точностью:

                      >>> Fraction('.25')
                      Fraction(1, 4)

Оба типа, Fraction и Decimal, предоставляют возможность получить точный результат, хотя и за счет некоторой потери производительности:

                      >>> Fraction(1, 10) + Fraction(1, 10) + Fraction(1, 10) - Fraction(3, 10)
                      Fraction(0, 1)

**Преобразование и смешивание в выражениях значений разных типов**

### множества
Неупорядоченная коллекция уникальных и неизменяемых объектов, которая поддерживает операции, соответствующие
математической теории множеств. Множества поддерживают итерации, могут изменяться в размерах и могут содержать
объекты разных типов. Множество напоминает словарь, ключи в котором не имеют значений.

Множества могут включать объекты только неизменяемых(или так называемых хэшируемых) типов. Отсюда следует, что
списки и словари не могут добавляться в множества. Т.к. множества изменяемы, следовательно они не могут
вкладываться в другие множества. Но с помощью функции frozenset можно создать неизменяемое множество, которое
невозможно изменить, и потому можно встраивать в другие множества.

                              >>> engineers = {'bob', 'sue', 'ann', 'vic'}
                              >>> managers = {'tom', 'sue'}

                              >>> 'bob' in engineers
                              True

                              >>> engineers & managers
                              {'sue'}

                              >>> engineers | managers
                              {'vic', 'sue', 'tom', 'bob', 'ann'}

                              >>> engineers – managers # Инженеры, не являющиеся менеджерами
                              {'vic', 'bob', 'ann'}

                              >>> managers – engineers # Менеджеры, не являющиеся инженерами
                              {'tom'}

                              >>> engineers > managers # Все менеджеры являются инженерами?
                              False # (надмножество)

                              >>> {'bob', 'sue'} < engineers # Оба сотрудника - инженеры? (подмножество)
                              True

### логические значения  
В языке Python имеется самостоятельный логический тип bool, с двумя предопределенными значениями True и False. Эти значения являются экземплярами класса bool, который в свою очередь является всего лишь подклассом (в объектно-ориентированном смысле) встроенного целочисленного типа int. True и False ведут себя точно так же, как и целые числа 1 и 0, за исключением того, что для их вывода на экран используется другая логика – они выводятся как слова True и False вместо цифр 1 и 0. Технически это достигается за счет переопределения в классе bool методов str и repr.

                            >>>  type(True)
                            <class 'bool'>

                            >>> isinstance(True, int)
                            True

                            >>> True == 1
                            True

                            >>> True + 4
                            5
